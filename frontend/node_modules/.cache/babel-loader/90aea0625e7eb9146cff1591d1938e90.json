{"ast":null,"code":"'use strict';\n\nvar $ = require('./$'),\n    hide = require('./$.hide'),\n    redefineAll = require('./$.redefine-all'),\n    ctx = require('./$.ctx'),\n    strictNew = require('./$.strict-new'),\n    defined = require('./$.defined'),\n    forOf = require('./$.for-of'),\n    $iterDefine = require('./$.iter-define'),\n    step = require('./$.iter-step'),\n    ID = require('./$.uid')('id'),\n    $has = require('./$.has'),\n    isObject = require('./$.is-object'),\n    setSpecies = require('./$.set-species'),\n    DESCRIPTORS = require('./$.descriptors'),\n    isExtensible = Object.isExtensible || isObject,\n    SIZE = DESCRIPTORS ? '_s' : 'size',\n    id = 0;\n\nvar fastKey = function (it, create) {\n  // return primitive with prefix\n  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n\n  if (!$has(it, ID)) {\n    // can't set id to frozen object\n    if (!isExtensible(it)) return 'F'; // not necessary to add id\n\n    if (!create) return 'E'; // add missing object id\n\n    hide(it, ID, ++id); // return object id with prefix\n  }\n\n  return 'O' + it[ID];\n};\n\nvar getEntry = function (that, key) {\n  // fast case\n  var index = fastKey(key),\n      entry;\n  if (index !== 'F') return that._i[index]; // frozen object case\n\n  for (entry = that._f; entry; entry = entry.n) {\n    if (entry.k == key) return entry;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      strictNew(that, C, NAME);\n      that._i = $.create(null); // index\n\n      that._f = undefined; // first entry\n\n      that._l = undefined; // last entry\n\n      that[SIZE] = 0; // size\n\n      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.1.3.1 Map.prototype.clear()\n      // 23.2.3.2 Set.prototype.clear()\n      clear: function clear() {\n        for (var that = this, data = that._i, entry = that._f; entry; entry = entry.n) {\n          entry.r = true;\n          if (entry.p) entry.p = entry.p.n = undefined;\n          delete data[entry.i];\n        }\n\n        that._f = that._l = undefined;\n        that[SIZE] = 0;\n      },\n      // 23.1.3.3 Map.prototype.delete(key)\n      // 23.2.3.4 Set.prototype.delete(value)\n      'delete': function (key) {\n        var that = this,\n            entry = getEntry(that, key);\n\n        if (entry) {\n          var next = entry.n,\n              prev = entry.p;\n          delete that._i[entry.i];\n          entry.r = true;\n          if (prev) prev.n = next;\n          if (next) next.p = prev;\n          if (that._f == entry) that._f = next;\n          if (that._l == entry) that._l = prev;\n          that[SIZE]--;\n        }\n\n        return !!entry;\n      },\n      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\n      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\n      forEach: function forEach(callbackfn\n      /*, that = undefined */\n      ) {\n        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3),\n            entry;\n\n        while (entry = entry ? entry.n : this._f) {\n          f(entry.v, entry.k, this); // revert to the last existing entry\n\n          while (entry && entry.r) entry = entry.p;\n        }\n      },\n      // 23.1.3.7 Map.prototype.has(key)\n      // 23.2.3.7 Set.prototype.has(value)\n      has: function has(key) {\n        return !!getEntry(this, key);\n      }\n    });\n    if (DESCRIPTORS) $.setDesc(C.prototype, 'size', {\n      get: function () {\n        return defined(this[SIZE]);\n      }\n    });\n    return C;\n  },\n  def: function (that, key, value) {\n    var entry = getEntry(that, key),\n        prev,\n        index; // change existing entry\n\n    if (entry) {\n      entry.v = value; // create new entry\n    } else {\n      that._l = entry = {\n        i: index = fastKey(key, true),\n        // <- index\n        k: key,\n        // <- key\n        v: value,\n        // <- value\n        p: prev = that._l,\n        // <- previous entry\n        n: undefined,\n        // <- next entry\n        r: false // <- removed\n\n      };\n      if (!that._f) that._f = entry;\n      if (prev) prev.n = entry;\n      that[SIZE]++; // add to index\n\n      if (index !== 'F') that._i[index] = entry;\n    }\n\n    return that;\n  },\n  getEntry: getEntry,\n  setStrong: function (C, NAME, IS_MAP) {\n    // add .keys, .values, .entries, [@@iterator]\n    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\n    $iterDefine(C, NAME, function (iterated, kind) {\n      this._t = iterated; // target\n\n      this._k = kind; // kind\n\n      this._l = undefined; // previous\n    }, function () {\n      var that = this,\n          kind = that._k,\n          entry = that._l; // revert to the last existing entry\n\n      while (entry && entry.r) entry = entry.p; // get next entry\n\n\n      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {\n        // or finish the iteration\n        that._t = undefined;\n        return step(1);\n      } // return step by kind\n\n\n      if (kind == 'keys') return step(0, entry.k);\n      if (kind == 'values') return step(0, entry.v);\n      return step(0, [entry.k, entry.v]);\n    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2\n\n    setSpecies(NAME);\n  }\n};","map":{"version":3,"sources":["E:/React/pos-system/frontend/node_modules/babel/node_modules/core-js/modules/$.collection-strong.js"],"names":["$","require","hide","redefineAll","ctx","strictNew","defined","forOf","$iterDefine","step","ID","$has","isObject","setSpecies","DESCRIPTORS","isExtensible","Object","SIZE","id","fastKey","it","create","getEntry","that","key","index","entry","_i","_f","n","k","module","exports","getConstructor","wrapper","NAME","IS_MAP","ADDER","C","iterable","undefined","_l","prototype","clear","data","r","p","i","next","prev","forEach","callbackfn","f","arguments","length","v","has","setDesc","get","def","value","setStrong","iterated","kind","_t","_k"],"mappings":"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","sourcesContent":["'use strict';\nvar $            = require('./$')\n  , hide         = require('./$.hide')\n  , redefineAll  = require('./$.redefine-all')\n  , ctx          = require('./$.ctx')\n  , strictNew    = require('./$.strict-new')\n  , defined      = require('./$.defined')\n  , forOf        = require('./$.for-of')\n  , $iterDefine  = require('./$.iter-define')\n  , step         = require('./$.iter-step')\n  , ID           = require('./$.uid')('id')\n  , $has         = require('./$.has')\n  , isObject     = require('./$.is-object')\n  , setSpecies   = require('./$.set-species')\n  , DESCRIPTORS  = require('./$.descriptors')\n  , isExtensible = Object.isExtensible || isObject\n  , SIZE         = DESCRIPTORS ? '_s' : 'size'\n  , id           = 0;\n\nvar fastKey = function(it, create){\n  // return primitive with prefix\n  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if(!$has(it, ID)){\n    // can't set id to frozen object\n    if(!isExtensible(it))return 'F';\n    // not necessary to add id\n    if(!create)return 'E';\n    // add missing object id\n    hide(it, ID, ++id);\n  // return object id with prefix\n  } return 'O' + it[ID];\n};\n\nvar getEntry = function(that, key){\n  // fast case\n  var index = fastKey(key), entry;\n  if(index !== 'F')return that._i[index];\n  // frozen object case\n  for(entry = that._f; entry; entry = entry.n){\n    if(entry.k == key)return entry;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){\n    var C = wrapper(function(that, iterable){\n      strictNew(that, C, NAME);\n      that._i = $.create(null); // index\n      that._f = undefined;      // first entry\n      that._l = undefined;      // last entry\n      that[SIZE] = 0;           // size\n      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.1.3.1 Map.prototype.clear()\n      // 23.2.3.2 Set.prototype.clear()\n      clear: function clear(){\n        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){\n          entry.r = true;\n          if(entry.p)entry.p = entry.p.n = undefined;\n          delete data[entry.i];\n        }\n        that._f = that._l = undefined;\n        that[SIZE] = 0;\n      },\n      // 23.1.3.3 Map.prototype.delete(key)\n      // 23.2.3.4 Set.prototype.delete(value)\n      'delete': function(key){\n        var that  = this\n          , entry = getEntry(that, key);\n        if(entry){\n          var next = entry.n\n            , prev = entry.p;\n          delete that._i[entry.i];\n          entry.r = true;\n          if(prev)prev.n = next;\n          if(next)next.p = prev;\n          if(that._f == entry)that._f = next;\n          if(that._l == entry)that._l = prev;\n          that[SIZE]--;\n        } return !!entry;\n      },\n      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\n      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\n      forEach: function forEach(callbackfn /*, that = undefined */){\n        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)\n          , entry;\n        while(entry = entry ? entry.n : this._f){\n          f(entry.v, entry.k, this);\n          // revert to the last existing entry\n          while(entry && entry.r)entry = entry.p;\n        }\n      },\n      // 23.1.3.7 Map.prototype.has(key)\n      // 23.2.3.7 Set.prototype.has(value)\n      has: function has(key){\n        return !!getEntry(this, key);\n      }\n    });\n    if(DESCRIPTORS)$.setDesc(C.prototype, 'size', {\n      get: function(){\n        return defined(this[SIZE]);\n      }\n    });\n    return C;\n  },\n  def: function(that, key, value){\n    var entry = getEntry(that, key)\n      , prev, index;\n    // change existing entry\n    if(entry){\n      entry.v = value;\n    // create new entry\n    } else {\n      that._l = entry = {\n        i: index = fastKey(key, true), // <- index\n        k: key,                        // <- key\n        v: value,                      // <- value\n        p: prev = that._l,             // <- previous entry\n        n: undefined,                  // <- next entry\n        r: false                       // <- removed\n      };\n      if(!that._f)that._f = entry;\n      if(prev)prev.n = entry;\n      that[SIZE]++;\n      // add to index\n      if(index !== 'F')that._i[index] = entry;\n    } return that;\n  },\n  getEntry: getEntry,\n  setStrong: function(C, NAME, IS_MAP){\n    // add .keys, .values, .entries, [@@iterator]\n    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\n    $iterDefine(C, NAME, function(iterated, kind){\n      this._t = iterated;  // target\n      this._k = kind;      // kind\n      this._l = undefined; // previous\n    }, function(){\n      var that  = this\n        , kind  = that._k\n        , entry = that._l;\n      // revert to the last existing entry\n      while(entry && entry.r)entry = entry.p;\n      // get next entry\n      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){\n        // or finish the iteration\n        that._t = undefined;\n        return step(1);\n      }\n      // return step by kind\n      if(kind == 'keys'  )return step(0, entry.k);\n      if(kind == 'values')return step(0, entry.v);\n      return step(0, [entry.k, entry.v]);\n    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);\n\n    // add [@@species], 23.1.2.2, 23.2.2.2\n    setSpecies(NAME);\n  }\n};"]},"metadata":{},"sourceType":"script"}