{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _clone from \"lodash/clone\";\nimport _isNil from \"lodash/isNil\";\nimport _isArray from \"lodash/isArray\";\nimport _omit from \"lodash/omit\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _intersection from \"lodash/intersection\";\nimport React, { useRef, useState, useEffect, useCallback } from 'react';\nimport shallowEqualArray from '../utils/shallowEqualArray';\nimport { getNodeCheckState } from '../CheckTreePicker/utils';\nimport { TREE_NODE_DROP_POSITION, shallowEqual } from '../utils';\nimport { shouldDisplay } from '../Picker';\nimport reactToString from './reactToString';\nimport { TREE_NODE_PADDING, TREE_NODE_ROOT_PADDING } from './constants'; // gap of tree node\n\nvar TREE_NODE_GAP = 4;\n/**\n * according node parentNode expand state decide node whether to show\n * @param {*} expandItemValues\n * @param {*} parentKeys\n */\n\nexport function shouldShowNodeByParentExpanded(expandItemValues, parentKeys) {\n  if (expandItemValues === void 0) {\n    expandItemValues = [];\n  }\n\n  if (parentKeys === void 0) {\n    parentKeys = [];\n  }\n\n  var intersectionKeys = _intersection(expandItemValues, parentKeys);\n\n  if (intersectionKeys.length === parentKeys.length) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * flatten tree structure to array\n * @param {*} tree\n * @param {*} childrenKey\n * @param {*} executor\n */\n\nexport function flattenTree(tree, childrenKey, executor) {\n  if (childrenKey === void 0) {\n    childrenKey = 'children';\n  }\n\n  var flattenData = [];\n\n  var traverse = function traverse(data, parent) {\n    if (!_isArray(data)) {\n      return;\n    }\n\n    data.forEach(function (item, index) {\n      var node = typeof executor === 'function' ? executor(item, index) : item;\n      node.parent = parent;\n      flattenData.push(_extends({}, node));\n\n      if (item[childrenKey]) {\n        traverse(item[childrenKey], item);\n      }\n    });\n  };\n\n  traverse(tree, null);\n  return flattenData;\n}\n/**\n * get all ancestor nodes of given node\n * @param {*} node\n */\n\nexport function getNodeParents(node, parentKey, valueKey) {\n  if (parentKey === void 0) {\n    parentKey = 'parent';\n  }\n\n  var parents = [];\n\n  var traverse = function traverse(node) {\n    if (node !== null && node !== void 0 && node[parentKey]) {\n      traverse(node[parentKey]);\n\n      if (valueKey) {\n        parents.push(node[parentKey][valueKey]);\n      } else {\n        parents.push(node[parentKey]);\n      }\n    }\n  };\n\n  traverse(node);\n  return parents;\n}\n/**\n * get all parentKeys of given node\n * @param nodes\n * @param node\n * @param valueKey\n */\n\nexport function getNodeParentKeys(nodes, node, valueKey) {\n  var parentKeys = [];\n\n  var traverse = function traverse(node) {\n    var _node$parent;\n\n    if (node !== null && node !== void 0 && (_node$parent = node.parent) !== null && _node$parent !== void 0 && _node$parent.refKey) {\n      var _node$parent2;\n\n      traverse(nodes[node.parent.refKey]);\n      parentKeys.push(node === null || node === void 0 ? void 0 : (_node$parent2 = node.parent) === null || _node$parent2 === void 0 ? void 0 : _node$parent2[valueKey]);\n    }\n  };\n\n  traverse(node);\n  return parentKeys;\n}\nexport function hasVisibleChildren(node, childrenKey) {\n  if (!Array.isArray(node[childrenKey])) {\n    return false;\n  }\n\n  return node[childrenKey].some(function (child) {\n    return child.visible;\n  });\n}\n/**\n * shallow equal array\n * @param a\n * @param b\n */\n\nexport function compareArray(a, b) {\n  return _isArray(a) && _isArray(b) && !shallowEqualArray(a, b);\n}\nexport function getDefaultExpandItemValues(data, props) {\n  var valueKey = props.valueKey,\n      defaultExpandAll = props.defaultExpandAll,\n      childrenKey = props.childrenKey,\n      _props$defaultExpandI = props.defaultExpandItemValues,\n      defaultExpandItemValues = _props$defaultExpandI === void 0 ? [] : _props$defaultExpandI;\n\n  if (defaultExpandAll) {\n    return flattenTree(data, childrenKey).filter(function (item) {\n      return Array.isArray(item[childrenKey]) && item[childrenKey].length > 0;\n    }).map(function (item) {\n      return item[valueKey];\n    });\n  }\n\n  return defaultExpandItemValues;\n}\n/**\n * 获取 expandItemValues 的 value\n * @param props\n */\n\nexport function getExpandItemValues(props) {\n  var expandItemValues = props.expandItemValues,\n      defaultExpandItemValues = props.defaultExpandItemValues;\n\n  if (!_isUndefined(expandItemValues) && Array.isArray(expandItemValues)) {\n    return expandItemValues;\n  }\n\n  if (!_isUndefined(defaultExpandItemValues) && Array.isArray(defaultExpandItemValues)) {\n    return defaultExpandItemValues;\n  }\n\n  return [];\n}\n/**\n * get dragNode and it's children node keys\n * @param node\n * @param childrenKey\n * @param valueKey\n */\n\nexport function getDragNodeKeys(dragNode, childrenKey, valueKey) {\n  var dragNodeKeys = [dragNode[valueKey]];\n\n  var traverse = function traverse(data) {\n    if ((data === null || data === void 0 ? void 0 : data.length) > 0) {\n      data.forEach(function (node) {\n        dragNodeKeys = dragNodeKeys.concat([node[valueKey]]);\n\n        if (node[childrenKey]) {\n          traverse(node[childrenKey]);\n        }\n      });\n    }\n  };\n\n  traverse(dragNode[childrenKey]);\n  return dragNodeKeys;\n}\nexport function calDropNodePosition(event, treeNodeElement) {\n  var clientY = event.clientY;\n\n  var _treeNodeElement$getB = treeNodeElement.getBoundingClientRect(),\n      top = _treeNodeElement$getB.top,\n      bottom = _treeNodeElement$getB.bottom;\n\n  var gap = TREE_NODE_GAP; // bottom of node\n\n  if (clientY >= bottom - gap && clientY <= bottom) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER_BOTTOM;\n  } // top of node\n\n\n  if (clientY <= top + gap && clientY >= top) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER_TOP;\n  }\n\n  if (clientY >= top + gap && clientY <= bottom - gap) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER;\n  }\n\n  return -1;\n}\nexport function removeDragNode(data, params, _ref) {\n  var valueKey = _ref.valueKey,\n      childrenKey = _ref.childrenKey;\n  var dragNode = params.dragNode;\n\n  var traverse = function traverse(items, parent) {\n    for (var _index = 0; _index < items.length; _index += 1) {\n      var _item = items[_index];\n\n      if (shallowEqual(_item[valueKey], dragNode[valueKey])) {\n        items.splice(_index, 1); // when children is empty, delete children prop for hidden anchor\n\n        if (items.length === 0 && parent) {\n          delete parent.children;\n        }\n\n        break;\n      }\n\n      if (Array.isArray(_item[childrenKey])) {\n        traverse(_item[childrenKey], _item);\n      }\n    }\n  };\n\n  traverse(data);\n}\nexport function createUpdateTreeDataFunction(params, _ref2) {\n  var valueKey = _ref2.valueKey,\n      childrenKey = _ref2.childrenKey;\n  return function (tree) {\n    var data = [].concat(tree);\n    var dragNode = params.dragNode,\n        dropNode = params.dropNode,\n        dropNodePosition = params.dropNodePosition;\n\n    var cloneDragNode = _extends({}, dragNode);\n\n    removeDragNode(data, params, {\n      valueKey: valueKey,\n      childrenKey: childrenKey\n    });\n\n    var updateTree = function updateTree(items) {\n      for (var _index2 = 0; _index2 < items.length; _index2 += 1) {\n        var _item2 = items[_index2];\n\n        if (shallowEqual(_item2[valueKey], dropNode[valueKey])) {\n          // drag to node inside\n          if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER) {\n            _item2[childrenKey] = _isNil(_item2[childrenKey]) ? [] : _item2[childrenKey];\n\n            _item2[childrenKey].push(cloneDragNode);\n\n            break;\n          } else if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER_TOP) {\n            // drag to top of node\n            items.splice(_index2, 0, cloneDragNode);\n            break;\n          } else if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER_BOTTOM) {\n            // drag to bottom of node\n            items.splice(_index2 + 1, 0, cloneDragNode);\n            break;\n          }\n        }\n\n        if (Array.isArray(_item2[childrenKey]) && _item2[childrenKey].length > 0) {\n          updateTree(_item2[childrenKey]);\n        }\n      }\n    };\n\n    updateTree(data);\n    return [].concat(data);\n  };\n}\nexport function findNodeOfTree(data, check) {\n  var findNode = function findNode(nodes) {\n    if (nodes === void 0) {\n      nodes = [];\n    }\n\n    for (var i = 0; i < nodes.length; i += 1) {\n      var _item3 = nodes[i];\n\n      if (_isArray(_item3.children)) {\n        var _node = findNode(_item3.children);\n\n        if (_node) {\n          return _node;\n        }\n      }\n\n      if (check(_item3)) {\n        return _item3;\n      }\n    }\n\n    return undefined;\n  };\n\n  return findNode(data);\n}\nexport function filterNodesOfTree(data, check) {\n  var findNodes = function findNodes(nodes) {\n    if (nodes === void 0) {\n      nodes = [];\n    }\n\n    var nextNodes = [];\n\n    for (var i = 0; i < nodes.length; i += 1) {\n      if (_isArray(nodes[i].children)) {\n        var nextChildren = findNodes(nodes[i].children);\n\n        if (nextChildren.length) {\n          var _item4 = _clone(nodes[i]);\n\n          _item4.children = nextChildren;\n          nextNodes.push(_item4);\n          continue;\n        }\n      }\n\n      if (check(nodes[i])) {\n        nextNodes.push(nodes[i]);\n      }\n    }\n\n    return nextNodes;\n  };\n\n  return findNodes(data);\n}\n/**\n * get all focusable items\n * exclude not visible and disabled node\n * @param filteredData - filtered tree data\n * @param props - TreeProps\n * @param isSearching - component is in Searching\n * @returns\n */\n\nexport var getFocusableItems = function getFocusableItems(filteredData, props, isSearching) {\n  var disabledItemValues = props.disabledItemValues,\n      valueKey = props.valueKey,\n      childrenKey = props.childrenKey,\n      expandItemValues = props.expandItemValues;\n  var items = [];\n\n  var loop = function loop(nodes) {\n    nodes.forEach(function (node) {\n      var disabled = disabledItemValues.some(function (disabledItem) {\n        return shallowEqual(disabledItem, node[valueKey]);\n      });\n\n      if (!disabled && node.visible) {\n        items.push(node);\n      } // always expand when searching\n\n\n      var expand = isSearching ? true : expandItemValues.includes(node[valueKey]);\n\n      if (node[childrenKey] && expand) {\n        loop(node[childrenKey]);\n      }\n    });\n  };\n\n  loop(filteredData);\n  return items;\n};\n/**\n * return all focusable Item and active Element index\n * @param focusItemValue\n * @param focusableItems items\n */\n\nexport var getActiveIndex = function getActiveIndex(focusItemValue, focusItems, valueKey) {\n  var activeIndex = -1;\n  focusItems.forEach(function (item, index) {\n    if (shallowEqual(item[valueKey], focusItemValue)) {\n      activeIndex = index;\n    }\n  });\n  return activeIndex;\n};\n/**\n * get current active element and node data\n * @param flattenNodes - flattenData\n */\n\nexport var getActiveItem = function getActiveItem(focusItemValue, flattenNodes, valueKey) {\n  var nodeData = null;\n  var activeNode = Object.values(flattenNodes).find(function (node) {\n    return shallowEqual(node[valueKey], focusItemValue);\n  });\n\n  if (activeNode) {\n    nodeData = activeNode;\n  }\n\n  return nodeData;\n};\nexport var getElementByDataKey = function getElementByDataKey(dataKey, treeNodesRefs, selector) {\n  var ele = treeNodesRefs[dataKey];\n\n  if (ele instanceof Element) {\n    return ele.querySelector(selector);\n  }\n\n  return null;\n};\n/**\n * focus to specify tree node\n * @param refKey - target node refKey\n * @param treeNodeRefs - all tree node refs object\n * @param selector - node css selector\n */\n\nexport var focusTreeNode = function focusTreeNode(refKey, treeNodeRefs, selector) {\n  var _node$focus;\n\n  var node = getElementByDataKey(refKey, treeNodeRefs, selector);\n  node === null || node === void 0 ? void 0 : (_node$focus = node.focus) === null || _node$focus === void 0 ? void 0 : _node$focus.call(node);\n};\n/**\n * focus next item with keyboard\n * @param param\n */\n\nexport var focusNextItem = function focusNextItem(_ref3) {\n  var focusItemValue = _ref3.focusItemValue,\n      focusableItems = _ref3.focusableItems,\n      treeNodesRefs = _ref3.treeNodesRefs,\n      selector = _ref3.selector,\n      valueKey = _ref3.valueKey,\n      callback = _ref3.callback;\n  var activeIndex = getActiveIndex(focusItemValue, focusableItems, valueKey);\n\n  if (focusableItems.length === 0) {\n    return;\n  }\n\n  var nextIndex = activeIndex === focusableItems.length - 1 ? 0 : activeIndex + 1;\n  var nextFocusItemValue = focusableItems[nextIndex][valueKey];\n  callback === null || callback === void 0 ? void 0 : callback(nextFocusItemValue);\n  focusTreeNode(focusableItems[nextIndex].refKey, treeNodesRefs, selector);\n};\n/**\n * focus prev item with keyboard\n * @param param\n */\n\nexport var focusPreviousItem = function focusPreviousItem(_ref4) {\n  var focusItemValue = _ref4.focusItemValue,\n      focusableItems = _ref4.focusableItems,\n      treeNodesRefs = _ref4.treeNodesRefs,\n      selector = _ref4.selector,\n      valueKey = _ref4.valueKey,\n      callback = _ref4.callback;\n  var activeIndex = getActiveIndex(focusItemValue, focusableItems, valueKey);\n\n  if (focusableItems.length === 0) {\n    return;\n  }\n\n  var prevIndex = activeIndex === 0 ? focusableItems.length - 1 : activeIndex - 1;\n  prevIndex = prevIndex >= 0 ? prevIndex : 0;\n  var prevFocusItemValue = focusableItems[prevIndex][valueKey];\n  callback === null || callback === void 0 ? void 0 : callback(prevFocusItemValue);\n  focusTreeNode(focusableItems[prevIndex].refKey, treeNodesRefs, selector);\n};\n/**\n * Left arrow keyboard event handler\n * When focus is on an open node, closes the node.\n * When focus is on a child node that is also either an end node or a closed node, moves focus to its parent node.\n * When focus is on a root node that is also either an end node or a closed node, does nothing.\n * @see https://www.w3.org/TR/wai-aria-practices/#TreeView\n */\n\nexport function leftArrowHandler(_ref5) {\n  var focusItem = _ref5.focusItem,\n      expand = _ref5.expand,\n      onExpand = _ref5.onExpand,\n      onFocusItem = _ref5.onFocusItem;\n\n  if (_isEmpty(focusItem)) {\n    return;\n  }\n\n  if (expand) {\n    onExpand(_extends({}, focusItem, {\n      expand: expand\n    }));\n  } else if (focusItem !== null && focusItem !== void 0 && focusItem.parent) {\n    onFocusItem();\n  }\n}\n/**\n * Right arrow keyboard event handler\n * When focus is on a closed node, opens the node; focus does not move.\n * When focus is on a open node, moves focus to the first child node.\n * When focus is on an end node, does nothing.\n * @see https://www.w3.org/TR/wai-aria-practices/#TreeView\n */\n\nexport function rightArrowHandler(_ref6) {\n  var focusItem = _ref6.focusItem,\n      expand = _ref6.expand,\n      childrenKey = _ref6.childrenKey,\n      onExpand = _ref6.onExpand,\n      onFocusItem = _ref6.onFocusItem;\n\n  if (_isEmpty(focusItem) || !Array.isArray(focusItem[childrenKey])) {\n    return;\n  }\n\n  if (!expand) {\n    onExpand(_extends({}, focusItem, {\n      expand: expand\n    }));\n  } else {\n    onFocusItem();\n  }\n}\n/**\n * get scrollIndex in virtualized list\n * @param nodes - data\n * @param value - activeItem value\n * @param valueKey\n */\n\nexport var getScrollToIndex = function getScrollToIndex(nodes, value, valueKey) {\n  return nodes.filter(function (n) {\n    return n.visible;\n  }).findIndex(function (item) {\n    return item[valueKey] === value;\n  });\n};\n/**\n * when searching, expand state always return true\n * @param searchKeyword\n * @param expand\n */\n\nexport function getExpandWhenSearching(searchKeyword, expand) {\n  return isSearching(searchKeyword) ? true : expand;\n}\n\nfunction getTreeActiveNode(nodes, value, valueKey) {\n  if (_isUndefined(value)) {\n    return undefined;\n  }\n\n  for (var refKey in nodes) {\n    if (shallowEqual(nodes[refKey][valueKey], value)) {\n      return nodes[refKey];\n    }\n  }\n}\n\nexport { getTreeActiveNode };\n/**\n * toggle tree node\n * @param param0\n */\n\nexport function toggleExpand(_ref7) {\n  var node = _ref7.node,\n      isExpand = _ref7.isExpand,\n      expandItemValues = _ref7.expandItemValues,\n      valueKey = _ref7.valueKey;\n  var newExpandItemValues = new Set(expandItemValues);\n\n  if (isExpand) {\n    newExpandItemValues.add(node[valueKey]);\n  } else {\n    newExpandItemValues.delete(node[valueKey]);\n  }\n\n  return Array.from(newExpandItemValues);\n}\nexport function getTreeNodeTitle(label) {\n  if (typeof label === 'string') {\n    return label;\n  } else if ( /*#__PURE__*/React.isValidElement(label)) {\n    var _nodes = reactToString(label);\n\n    return _nodes.join('');\n  }\n}\n/**\n * get all children from flattenNodes object by given parent node\n * @param nodes\n * @param parent\n */\n\nexport function getChildrenByFlattenNodes(nodes, parent) {\n  if (!_isNil(parent.refKey) && _isNil(nodes[parent.refKey])) {\n    return [];\n  }\n\n  return Object.values(nodes).filter(function (item) {\n    var _item$parent;\n\n    return (item === null || item === void 0 ? void 0 : (_item$parent = item.parent) === null || _item$parent === void 0 ? void 0 : _item$parent.refKey) === parent.refKey && item.refKey && !nodes[item.refKey].uncheckable;\n  });\n}\nexport function useTreeDrag() {\n  // current dragging node\n  var dragNode = useRef(null);\n\n  var _useState = useState(null),\n      dragOverNodeKey = _useState[0],\n      setDragOverNodeKey = _useState[1]; // drag node and it's children nodes key\n\n\n  var _useState2 = useState([]),\n      dragNodeKeys = _useState2[0],\n      setDragNodeKeys = _useState2[1];\n\n  var _useState3 = useState(null),\n      dropNodePosition = _useState3[0],\n      setDropNodePosition = _useState3[1];\n\n  var setDragNode = function setDragNode(node) {\n    dragNode.current = node;\n  };\n\n  return {\n    dragNode: dragNode === null || dragNode === void 0 ? void 0 : dragNode.current,\n    dragOverNodeKey: dragOverNodeKey,\n    dragNodeKeys: dragNodeKeys,\n    dropNodePosition: dropNodePosition,\n    setDragNode: setDragNode,\n    setDragOverNodeKey: setDragOverNodeKey,\n    setDragNodeKeys: setDragNodeKeys,\n    setDropNodePosition: setDropNodePosition\n  };\n}\n/**\n * hooks for flatten tree structure\n * @param param0\n */\n\nexport function useFlattenTreeData(_ref8) {\n  var data = _ref8.data,\n      labelKey = _ref8.labelKey,\n      valueKey = _ref8.valueKey,\n      childrenKey = _ref8.childrenKey,\n      _ref8$uncheckableItem = _ref8.uncheckableItemValues,\n      uncheckableItemValues = _ref8$uncheckableItem === void 0 ? [] : _ref8$uncheckableItem,\n      callback = _ref8.callback;\n\n  var _useState4 = useState(Object.create(null)),\n      dispatch = _useState4[1];\n\n  var forceUpdate = useCallback(function () {\n    dispatch(Object.create(null));\n  }, [dispatch]);\n  var flattenNodes = useRef({});\n  var flattenTreeData = useCallback(function (treeData, ref, parent, layer) {\n    if (layer === void 0) {\n      layer = 1;\n    }\n\n    if (!Array.isArray(treeData) || treeData.length === 0) {\n      return [];\n    }\n\n    treeData.map(function (node, index) {\n      var _extends2;\n\n      var refKey = ref + \"-\" + index;\n      node.refKey = refKey;\n      flattenNodes.current[refKey] = _extends((_extends2 = {\n        layer: layer\n      }, _extends2[labelKey] = node[labelKey], _extends2[valueKey] = node[valueKey], _extends2.uncheckable = uncheckableItemValues.some(function (value) {\n        return shallowEqual(node[valueKey], value);\n      }), _extends2), node);\n\n      if (parent) {\n        flattenNodes.current[refKey].parent = _omit(parent, 'parent', 'children');\n      }\n\n      flattenTreeData(node[childrenKey], refKey, node, layer + 1);\n    });\n    callback === null || callback === void 0 ? void 0 : callback(flattenNodes.current);\n  }, [childrenKey, valueKey, labelKey, callback, uncheckableItemValues]);\n  var serializeListOnlyParent = useCallback(function (nodes, key) {\n    var list = [];\n    Object.keys(nodes).forEach(function (refKey) {\n      var currentNode = nodes[refKey];\n\n      if (!_isNil(currentNode.parent) && !_isNil(currentNode.parent.refKey)) {\n        var parentNode = nodes[currentNode.parent.refKey];\n\n        if (currentNode[key]) {\n          if (!(parentNode !== null && parentNode !== void 0 && parentNode.checkAll)) {\n            list.push(nodes[refKey][valueKey]);\n          } else if (parentNode !== null && parentNode !== void 0 && parentNode.uncheckable) {\n            list.push(nodes[refKey][valueKey]);\n          }\n        }\n      } else {\n        if (currentNode[key]) {\n          list.push(nodes[refKey][valueKey]);\n        }\n      }\n    });\n    return list;\n  }, [valueKey]);\n  /**\n   * using in CheckTreePicker, to unSerializeList check property\n   */\n\n  var unSerializeList = useCallback(function (_ref9) {\n    var nodes = _ref9.nodes,\n        key = _ref9.key,\n        _ref9$value = _ref9.value,\n        value = _ref9$value === void 0 ? [] : _ref9$value,\n        cascade = _ref9.cascade,\n        uncheckableItemValues = _ref9.uncheckableItemValues; // Reset values to false\n\n    Object.keys(nodes).forEach(function (refKey) {\n      var node = nodes[refKey];\n\n      if (cascade && !_isNil(node.parent) && !_isNil(node.parent.refKey)) {\n        node[key] = nodes[node.parent.refKey][key];\n      } else {\n        node[key] = false;\n      }\n\n      value.forEach(function (value) {\n        if (shallowEqual(nodes[refKey][valueKey], value) && !uncheckableItemValues.some(function (uncheckableValue) {\n          return shallowEqual(value, uncheckableValue);\n        })) {\n          nodes[refKey][key] = true;\n        }\n      });\n    });\n  }, [valueKey]);\n\n  var formatVirtualizedTreeData = function formatVirtualizedTreeData(nodes, data, expandItemValues, options) {\n    var cascade = options.cascade,\n        searchKeyword = options.searchKeyword;\n    return flattenTree(data, childrenKey, function (node) {\n      var formatted = {};\n      var curNode = nodes === null || nodes === void 0 ? void 0 : nodes[node.refKey];\n      var parentKeys = getNodeParentKeys(nodes, curNode, valueKey);\n      /**\n       * When using virtualized,\n       * if the parent node is collapsed, the child nodes should be hidden\n       * avoid component height calculation errors\n       */\n\n      var visible = curNode !== null && curNode !== void 0 && curNode.parent ? shouldShowNodeByParentExpanded(expandItemValues, parentKeys) : true;\n      /**\n       * when searching, every node default expand\n       * the node's visible should follow the original state\n       */\n\n      if (isSearching(searchKeyword)) {\n        visible = node.visible;\n      }\n\n      if (curNode) {\n        var checkState = !_isUndefined(cascade) ? getNodeCheckState({\n          node: curNode,\n          cascade: cascade,\n          nodes: nodes,\n          childrenKey: childrenKey\n        }) : undefined;\n        formatted = _extends({}, node, {\n          check: curNode.check,\n          uncheckable: curNode.uncheckable,\n          hasChildren: !!node[childrenKey],\n          layer: curNode.layer,\n          parent: curNode.parent,\n          checkState: checkState,\n          visible: visible\n        });\n      }\n\n      return formatted;\n    });\n  };\n\n  useEffect(function () {\n    // when data is changed, should clear the flattenNodes, avoid duplicate keys\n    flattenNodes.current = {};\n    flattenTreeData(data, '0');\n  }, [data]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return {\n    forceUpdate: forceUpdate,\n    flattenNodes: flattenNodes.current,\n    flattenTreeData: flattenTreeData,\n    serializeListOnlyParent: serializeListOnlyParent,\n    unSerializeList: unSerializeList,\n    formatVirtualizedTreeData: formatVirtualizedTreeData\n  };\n}\n/**\n * A hook that saving every tree node ref\n */\n\nexport function useTreeNodeRefs() {\n  var treeNodeRefs = useRef({});\n\n  var saveTreeNodeRef = function saveTreeNodeRef(ref, refKey) {\n    if (!_isNil(refKey)) {\n      treeNodeRefs.current[refKey] = ref;\n    }\n  };\n\n  return {\n    treeNodesRefs: treeNodeRefs.current,\n    saveTreeNodeRef: saveTreeNodeRef\n  };\n}\n/**\n * A hook that handles tree search filter options\n * @param props\n */\n\nexport function useTreeSearch(props) {\n  var labelKey = props.labelKey,\n      childrenKey = props.childrenKey,\n      searchKeyword = props.searchKeyword,\n      data = props.data,\n      searchBy = props.searchBy,\n      callback = props.callback;\n  var filterVisibleData = useCallback(function (data, searchKeyword) {\n    var setVisible = function setVisible(nodes) {\n      return nodes.forEach(function (item) {\n        item.visible = searchBy ? searchBy(searchKeyword, item[labelKey], item) : shouldDisplay(item[labelKey], searchKeyword);\n\n        if (_isArray(item[childrenKey])) {\n          filterVisibleData(item[childrenKey], searchKeyword);\n          item[childrenKey].forEach(function (child) {\n            if (child.visible) {\n              item.visible = child.visible;\n            }\n          });\n        }\n      });\n    };\n\n    setVisible(data);\n    return data;\n  }, [childrenKey, labelKey, searchBy]); // Use search keywords to filter options.\n\n  var _useState5 = useState(function () {\n    return searchKeyword !== null && searchKeyword !== void 0 ? searchKeyword : '';\n  }),\n      searchKeywordState = _useState5[0],\n      setSearchKeyword = _useState5[1];\n\n  var _useState6 = useState(function () {\n    return filterVisibleData(data, searchKeywordState);\n  }),\n      filteredData = _useState6[0],\n      setFilteredData = _useState6[1];\n\n  var handleSetFilteredData = useCallback(function (data, searchKeyword) {\n    setFilteredData(filterVisibleData(data, searchKeyword));\n  }, [filterVisibleData]);\n\n  var handleSearch = function handleSearch(searchKeyword, event) {\n    var filteredData = filterVisibleData(data, searchKeyword);\n    setFilteredData(filteredData);\n    setSearchKeyword(searchKeyword);\n    callback === null || callback === void 0 ? void 0 : callback(searchKeyword, filteredData, event);\n  };\n\n  return {\n    searchKeywordState: searchKeywordState,\n    filteredData: filteredData,\n    setFilteredData: handleSetFilteredData,\n    setSearchKeyword: setSearchKeyword,\n    handleSearch: handleSearch\n  };\n}\nexport function useGetTreeNodeChildren(treeData, valueKey, childrenKey) {\n  var _useState7 = useState([]),\n      loadingNodeValues = _useState7[0],\n      setLoadingNodeValues = _useState7[1];\n\n  var _useState8 = useState(treeData),\n      data = _useState8[0],\n      setData = _useState8[1];\n\n  var concatChildren = useCallback(function (treeNode, children) {\n    var value = treeNode[valueKey];\n    treeNode = findNodeOfTree(data, function (item) {\n      return value === item[valueKey];\n    });\n    treeNode[childrenKey] = children;\n    var newData = data.concat([]);\n    setData(newData);\n    return newData;\n  }, [data, valueKey, childrenKey]);\n  var loadChildren = useCallback(function (node, getChildren) {\n    setLoadingNodeValues(function (prev) {\n      return prev.concat(node[valueKey]);\n    });\n    var children = getChildren(node);\n\n    if (children instanceof Promise) {\n      children.then(function (res) {\n        var newData = concatChildren(node, res);\n        setData(newData);\n        setLoadingNodeValues(function (prev) {\n          return prev.filter(function (item) {\n            return !shallowEqual(item, node[valueKey]);\n          });\n        });\n      });\n    } else {\n      setData(concatChildren(node, children));\n      setLoadingNodeValues(function (prev) {\n        return prev.filter(function (item) {\n          return !shallowEqual(item, node[valueKey]);\n        });\n      });\n    }\n  }, [concatChildren, valueKey]);\n  return {\n    data: data,\n    setData: setData,\n    loadingNodeValues: loadingNodeValues,\n    loadChildren: loadChildren\n  };\n}\n/**\n * Focus to active tree node.\n * @param param0\n */\n\nexport function focusToActiveTreeNode(_ref10) {\n  var _activeItem$focus;\n\n  var list = _ref10.list,\n      valueKey = _ref10.valueKey,\n      activeNode = _ref10.activeNode,\n      virtualized = _ref10.virtualized,\n      container = _ref10.container,\n      selector = _ref10.selector,\n      formattedNodes = _ref10.formattedNodes;\n  if (!container) return;\n\n  if (virtualized && activeNode) {\n    var _list$scrollToRow;\n\n    var scrollIndex = getScrollToIndex(formattedNodes, activeNode === null || activeNode === void 0 ? void 0 : activeNode[valueKey], valueKey);\n    (_list$scrollToRow = list.scrollToRow) === null || _list$scrollToRow === void 0 ? void 0 : _list$scrollToRow.call(list, scrollIndex);\n    return;\n  }\n\n  var activeItem = container.querySelector(selector);\n\n  if (!activeItem) {\n    return;\n  }\n\n  activeItem === null || activeItem === void 0 ? void 0 : (_activeItem$focus = activeItem.focus) === null || _activeItem$focus === void 0 ? void 0 : _activeItem$focus.call(activeItem);\n}\nexport function isSearching(searchKeyword) {\n  return !_isEmpty(searchKeyword);\n}\nexport function getTreeNodeIndent(rtl, layer, absolute) {\n  var _ref12;\n\n  if (absolute === void 0) {\n    absolute = false;\n  } // layer start from 1\n\n\n  var offset = layer * TREE_NODE_PADDING + TREE_NODE_ROOT_PADDING;\n\n  if (absolute) {\n    var _ref11;\n\n    return _ref11 = {}, _ref11[rtl ? 'right' : 'left'] = offset, _ref11;\n  }\n\n  return _ref12 = {}, _ref12[rtl ? 'paddingRight' : 'paddingLeft'] = offset, _ref12;\n}","map":{"version":3,"sources":["E:/React/pos-system/main/node_modules/rsuite/esm/utils/treeUtils.js"],"names":["_extends","_isEmpty","_clone","_isNil","_isArray","_omit","_isUndefined","_intersection","React","useRef","useState","useEffect","useCallback","shallowEqualArray","getNodeCheckState","TREE_NODE_DROP_POSITION","shallowEqual","shouldDisplay","reactToString","TREE_NODE_PADDING","TREE_NODE_ROOT_PADDING","TREE_NODE_GAP","shouldShowNodeByParentExpanded","expandItemValues","parentKeys","intersectionKeys","length","flattenTree","tree","childrenKey","executor","flattenData","traverse","data","parent","forEach","item","index","node","push","getNodeParents","parentKey","valueKey","parents","getNodeParentKeys","nodes","_node$parent","refKey","_node$parent2","hasVisibleChildren","Array","isArray","some","child","visible","compareArray","a","b","getDefaultExpandItemValues","props","defaultExpandAll","_props$defaultExpandI","defaultExpandItemValues","filter","map","getExpandItemValues","getDragNodeKeys","dragNode","dragNodeKeys","concat","calDropNodePosition","event","treeNodeElement","clientY","_treeNodeElement$getB","getBoundingClientRect","top","bottom","gap","DRAG_OVER_BOTTOM","DRAG_OVER_TOP","DRAG_OVER","removeDragNode","params","_ref","items","_index","_item","splice","children","createUpdateTreeDataFunction","_ref2","dropNode","dropNodePosition","cloneDragNode","updateTree","_index2","_item2","findNodeOfTree","check","findNode","i","_item3","_node","undefined","filterNodesOfTree","findNodes","nextNodes","nextChildren","_item4","getFocusableItems","filteredData","isSearching","disabledItemValues","loop","disabled","disabledItem","expand","includes","getActiveIndex","focusItemValue","focusItems","activeIndex","getActiveItem","flattenNodes","nodeData","activeNode","Object","values","find","getElementByDataKey","dataKey","treeNodesRefs","selector","ele","Element","querySelector","focusTreeNode","treeNodeRefs","_node$focus","focus","call","focusNextItem","_ref3","focusableItems","callback","nextIndex","nextFocusItemValue","focusPreviousItem","_ref4","prevIndex","prevFocusItemValue","leftArrowHandler","_ref5","focusItem","onExpand","onFocusItem","rightArrowHandler","_ref6","getScrollToIndex","value","n","findIndex","getExpandWhenSearching","searchKeyword","getTreeActiveNode","toggleExpand","_ref7","isExpand","newExpandItemValues","Set","add","delete","from","getTreeNodeTitle","label","isValidElement","_nodes","join","getChildrenByFlattenNodes","_item$parent","uncheckable","useTreeDrag","_useState","dragOverNodeKey","setDragOverNodeKey","_useState2","setDragNodeKeys","_useState3","setDropNodePosition","setDragNode","current","useFlattenTreeData","_ref8","labelKey","_ref8$uncheckableItem","uncheckableItemValues","_useState4","create","dispatch","forceUpdate","flattenTreeData","treeData","ref","layer","_extends2","serializeListOnlyParent","key","list","keys","currentNode","parentNode","checkAll","unSerializeList","_ref9","_ref9$value","cascade","uncheckableValue","formatVirtualizedTreeData","options","formatted","curNode","checkState","hasChildren","useTreeNodeRefs","saveTreeNodeRef","useTreeSearch","searchBy","filterVisibleData","setVisible","_useState5","searchKeywordState","setSearchKeyword","_useState6","setFilteredData","handleSetFilteredData","handleSearch","useGetTreeNodeChildren","_useState7","loadingNodeValues","setLoadingNodeValues","_useState8","setData","concatChildren","treeNode","newData","loadChildren","getChildren","prev","Promise","then","res","focusToActiveTreeNode","_ref10","_activeItem$focus","virtualized","container","formattedNodes","_list$scrollToRow","scrollIndex","scrollToRow","activeItem","getTreeNodeIndent","rtl","absolute","_ref12","offset","_ref11"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _clone from \"lodash/clone\";\nimport _isNil from \"lodash/isNil\";\nimport _isArray from \"lodash/isArray\";\nimport _omit from \"lodash/omit\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _intersection from \"lodash/intersection\";\nimport React, { useRef, useState, useEffect, useCallback } from 'react';\nimport shallowEqualArray from '../utils/shallowEqualArray';\nimport { getNodeCheckState } from '../CheckTreePicker/utils';\nimport { TREE_NODE_DROP_POSITION, shallowEqual } from '../utils';\nimport { shouldDisplay } from '../Picker';\nimport reactToString from './reactToString';\nimport { TREE_NODE_PADDING, TREE_NODE_ROOT_PADDING } from './constants';\n// gap of tree node\nvar TREE_NODE_GAP = 4;\n/**\n * according node parentNode expand state decide node whether to show\n * @param {*} expandItemValues\n * @param {*} parentKeys\n */\n\nexport function shouldShowNodeByParentExpanded(expandItemValues, parentKeys) {\n  if (expandItemValues === void 0) {\n    expandItemValues = [];\n  }\n\n  if (parentKeys === void 0) {\n    parentKeys = [];\n  }\n\n  var intersectionKeys = _intersection(expandItemValues, parentKeys);\n\n  if (intersectionKeys.length === parentKeys.length) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * flatten tree structure to array\n * @param {*} tree\n * @param {*} childrenKey\n * @param {*} executor\n */\n\nexport function flattenTree(tree, childrenKey, executor) {\n  if (childrenKey === void 0) {\n    childrenKey = 'children';\n  }\n\n  var flattenData = [];\n\n  var traverse = function traverse(data, parent) {\n    if (!_isArray(data)) {\n      return;\n    }\n\n    data.forEach(function (item, index) {\n      var node = typeof executor === 'function' ? executor(item, index) : item;\n      node.parent = parent;\n      flattenData.push(_extends({}, node));\n\n      if (item[childrenKey]) {\n        traverse(item[childrenKey], item);\n      }\n    });\n  };\n\n  traverse(tree, null);\n  return flattenData;\n}\n/**\n * get all ancestor nodes of given node\n * @param {*} node\n */\n\nexport function getNodeParents(node, parentKey, valueKey) {\n  if (parentKey === void 0) {\n    parentKey = 'parent';\n  }\n\n  var parents = [];\n\n  var traverse = function traverse(node) {\n    if (node !== null && node !== void 0 && node[parentKey]) {\n      traverse(node[parentKey]);\n\n      if (valueKey) {\n        parents.push(node[parentKey][valueKey]);\n      } else {\n        parents.push(node[parentKey]);\n      }\n    }\n  };\n\n  traverse(node);\n  return parents;\n}\n/**\n * get all parentKeys of given node\n * @param nodes\n * @param node\n * @param valueKey\n */\n\nexport function getNodeParentKeys(nodes, node, valueKey) {\n  var parentKeys = [];\n\n  var traverse = function traverse(node) {\n    var _node$parent;\n\n    if (node !== null && node !== void 0 && (_node$parent = node.parent) !== null && _node$parent !== void 0 && _node$parent.refKey) {\n      var _node$parent2;\n\n      traverse(nodes[node.parent.refKey]);\n      parentKeys.push(node === null || node === void 0 ? void 0 : (_node$parent2 = node.parent) === null || _node$parent2 === void 0 ? void 0 : _node$parent2[valueKey]);\n    }\n  };\n\n  traverse(node);\n  return parentKeys;\n}\nexport function hasVisibleChildren(node, childrenKey) {\n  if (!Array.isArray(node[childrenKey])) {\n    return false;\n  }\n\n  return node[childrenKey].some(function (child) {\n    return child.visible;\n  });\n}\n/**\n * shallow equal array\n * @param a\n * @param b\n */\n\nexport function compareArray(a, b) {\n  return _isArray(a) && _isArray(b) && !shallowEqualArray(a, b);\n}\nexport function getDefaultExpandItemValues(data, props) {\n  var valueKey = props.valueKey,\n      defaultExpandAll = props.defaultExpandAll,\n      childrenKey = props.childrenKey,\n      _props$defaultExpandI = props.defaultExpandItemValues,\n      defaultExpandItemValues = _props$defaultExpandI === void 0 ? [] : _props$defaultExpandI;\n\n  if (defaultExpandAll) {\n    return flattenTree(data, childrenKey).filter(function (item) {\n      return Array.isArray(item[childrenKey]) && item[childrenKey].length > 0;\n    }).map(function (item) {\n      return item[valueKey];\n    });\n  }\n\n  return defaultExpandItemValues;\n}\n/**\n * 获取 expandItemValues 的 value\n * @param props\n */\n\nexport function getExpandItemValues(props) {\n  var expandItemValues = props.expandItemValues,\n      defaultExpandItemValues = props.defaultExpandItemValues;\n\n  if (!_isUndefined(expandItemValues) && Array.isArray(expandItemValues)) {\n    return expandItemValues;\n  }\n\n  if (!_isUndefined(defaultExpandItemValues) && Array.isArray(defaultExpandItemValues)) {\n    return defaultExpandItemValues;\n  }\n\n  return [];\n}\n/**\n * get dragNode and it's children node keys\n * @param node\n * @param childrenKey\n * @param valueKey\n */\n\nexport function getDragNodeKeys(dragNode, childrenKey, valueKey) {\n  var dragNodeKeys = [dragNode[valueKey]];\n\n  var traverse = function traverse(data) {\n    if ((data === null || data === void 0 ? void 0 : data.length) > 0) {\n      data.forEach(function (node) {\n        dragNodeKeys = dragNodeKeys.concat([node[valueKey]]);\n\n        if (node[childrenKey]) {\n          traverse(node[childrenKey]);\n        }\n      });\n    }\n  };\n\n  traverse(dragNode[childrenKey]);\n  return dragNodeKeys;\n}\nexport function calDropNodePosition(event, treeNodeElement) {\n  var clientY = event.clientY;\n\n  var _treeNodeElement$getB = treeNodeElement.getBoundingClientRect(),\n      top = _treeNodeElement$getB.top,\n      bottom = _treeNodeElement$getB.bottom;\n\n  var gap = TREE_NODE_GAP; // bottom of node\n\n  if (clientY >= bottom - gap && clientY <= bottom) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER_BOTTOM;\n  } // top of node\n\n\n  if (clientY <= top + gap && clientY >= top) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER_TOP;\n  }\n\n  if (clientY >= top + gap && clientY <= bottom - gap) {\n    return TREE_NODE_DROP_POSITION.DRAG_OVER;\n  }\n\n  return -1;\n}\nexport function removeDragNode(data, params, _ref) {\n  var valueKey = _ref.valueKey,\n      childrenKey = _ref.childrenKey;\n  var dragNode = params.dragNode;\n\n  var traverse = function traverse(items, parent) {\n    for (var _index = 0; _index < items.length; _index += 1) {\n      var _item = items[_index];\n\n      if (shallowEqual(_item[valueKey], dragNode[valueKey])) {\n        items.splice(_index, 1); // when children is empty, delete children prop for hidden anchor\n\n        if (items.length === 0 && parent) {\n          delete parent.children;\n        }\n\n        break;\n      }\n\n      if (Array.isArray(_item[childrenKey])) {\n        traverse(_item[childrenKey], _item);\n      }\n    }\n  };\n\n  traverse(data);\n}\nexport function createUpdateTreeDataFunction(params, _ref2) {\n  var valueKey = _ref2.valueKey,\n      childrenKey = _ref2.childrenKey;\n  return function (tree) {\n    var data = [].concat(tree);\n    var dragNode = params.dragNode,\n        dropNode = params.dropNode,\n        dropNodePosition = params.dropNodePosition;\n\n    var cloneDragNode = _extends({}, dragNode);\n\n    removeDragNode(data, params, {\n      valueKey: valueKey,\n      childrenKey: childrenKey\n    });\n\n    var updateTree = function updateTree(items) {\n      for (var _index2 = 0; _index2 < items.length; _index2 += 1) {\n        var _item2 = items[_index2];\n\n        if (shallowEqual(_item2[valueKey], dropNode[valueKey])) {\n          // drag to node inside\n          if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER) {\n            _item2[childrenKey] = _isNil(_item2[childrenKey]) ? [] : _item2[childrenKey];\n\n            _item2[childrenKey].push(cloneDragNode);\n\n            break;\n          } else if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER_TOP) {\n            // drag to top of node\n            items.splice(_index2, 0, cloneDragNode);\n            break;\n          } else if (dropNodePosition === TREE_NODE_DROP_POSITION.DRAG_OVER_BOTTOM) {\n            // drag to bottom of node\n            items.splice(_index2 + 1, 0, cloneDragNode);\n            break;\n          }\n        }\n\n        if (Array.isArray(_item2[childrenKey]) && _item2[childrenKey].length > 0) {\n          updateTree(_item2[childrenKey]);\n        }\n      }\n    };\n\n    updateTree(data);\n    return [].concat(data);\n  };\n}\nexport function findNodeOfTree(data, check) {\n  var findNode = function findNode(nodes) {\n    if (nodes === void 0) {\n      nodes = [];\n    }\n\n    for (var i = 0; i < nodes.length; i += 1) {\n      var _item3 = nodes[i];\n\n      if (_isArray(_item3.children)) {\n        var _node = findNode(_item3.children);\n\n        if (_node) {\n          return _node;\n        }\n      }\n\n      if (check(_item3)) {\n        return _item3;\n      }\n    }\n\n    return undefined;\n  };\n\n  return findNode(data);\n}\nexport function filterNodesOfTree(data, check) {\n  var findNodes = function findNodes(nodes) {\n    if (nodes === void 0) {\n      nodes = [];\n    }\n\n    var nextNodes = [];\n\n    for (var i = 0; i < nodes.length; i += 1) {\n      if (_isArray(nodes[i].children)) {\n        var nextChildren = findNodes(nodes[i].children);\n\n        if (nextChildren.length) {\n          var _item4 = _clone(nodes[i]);\n\n          _item4.children = nextChildren;\n          nextNodes.push(_item4);\n          continue;\n        }\n      }\n\n      if (check(nodes[i])) {\n        nextNodes.push(nodes[i]);\n      }\n    }\n\n    return nextNodes;\n  };\n\n  return findNodes(data);\n}\n/**\n * get all focusable items\n * exclude not visible and disabled node\n * @param filteredData - filtered tree data\n * @param props - TreeProps\n * @param isSearching - component is in Searching\n * @returns\n */\n\nexport var getFocusableItems = function getFocusableItems(filteredData, props, isSearching) {\n  var disabledItemValues = props.disabledItemValues,\n      valueKey = props.valueKey,\n      childrenKey = props.childrenKey,\n      expandItemValues = props.expandItemValues;\n  var items = [];\n\n  var loop = function loop(nodes) {\n    nodes.forEach(function (node) {\n      var disabled = disabledItemValues.some(function (disabledItem) {\n        return shallowEqual(disabledItem, node[valueKey]);\n      });\n\n      if (!disabled && node.visible) {\n        items.push(node);\n      } // always expand when searching\n\n\n      var expand = isSearching ? true : expandItemValues.includes(node[valueKey]);\n\n      if (node[childrenKey] && expand) {\n        loop(node[childrenKey]);\n      }\n    });\n  };\n\n  loop(filteredData);\n  return items;\n};\n/**\n * return all focusable Item and active Element index\n * @param focusItemValue\n * @param focusableItems items\n */\n\nexport var getActiveIndex = function getActiveIndex(focusItemValue, focusItems, valueKey) {\n  var activeIndex = -1;\n  focusItems.forEach(function (item, index) {\n    if (shallowEqual(item[valueKey], focusItemValue)) {\n      activeIndex = index;\n    }\n  });\n  return activeIndex;\n};\n/**\n * get current active element and node data\n * @param flattenNodes - flattenData\n */\n\nexport var getActiveItem = function getActiveItem(focusItemValue, flattenNodes, valueKey) {\n  var nodeData = null;\n  var activeNode = Object.values(flattenNodes).find(function (node) {\n    return shallowEqual(node[valueKey], focusItemValue);\n  });\n\n  if (activeNode) {\n    nodeData = activeNode;\n  }\n\n  return nodeData;\n};\nexport var getElementByDataKey = function getElementByDataKey(dataKey, treeNodesRefs, selector) {\n  var ele = treeNodesRefs[dataKey];\n\n  if (ele instanceof Element) {\n    return ele.querySelector(selector);\n  }\n\n  return null;\n};\n/**\n * focus to specify tree node\n * @param refKey - target node refKey\n * @param treeNodeRefs - all tree node refs object\n * @param selector - node css selector\n */\n\nexport var focusTreeNode = function focusTreeNode(refKey, treeNodeRefs, selector) {\n  var _node$focus;\n\n  var node = getElementByDataKey(refKey, treeNodeRefs, selector);\n  node === null || node === void 0 ? void 0 : (_node$focus = node.focus) === null || _node$focus === void 0 ? void 0 : _node$focus.call(node);\n};\n\n/**\n * focus next item with keyboard\n * @param param\n */\nexport var focusNextItem = function focusNextItem(_ref3) {\n  var focusItemValue = _ref3.focusItemValue,\n      focusableItems = _ref3.focusableItems,\n      treeNodesRefs = _ref3.treeNodesRefs,\n      selector = _ref3.selector,\n      valueKey = _ref3.valueKey,\n      callback = _ref3.callback;\n  var activeIndex = getActiveIndex(focusItemValue, focusableItems, valueKey);\n\n  if (focusableItems.length === 0) {\n    return;\n  }\n\n  var nextIndex = activeIndex === focusableItems.length - 1 ? 0 : activeIndex + 1;\n  var nextFocusItemValue = focusableItems[nextIndex][valueKey];\n  callback === null || callback === void 0 ? void 0 : callback(nextFocusItemValue);\n  focusTreeNode(focusableItems[nextIndex].refKey, treeNodesRefs, selector);\n};\n/**\n * focus prev item with keyboard\n * @param param\n */\n\nexport var focusPreviousItem = function focusPreviousItem(_ref4) {\n  var focusItemValue = _ref4.focusItemValue,\n      focusableItems = _ref4.focusableItems,\n      treeNodesRefs = _ref4.treeNodesRefs,\n      selector = _ref4.selector,\n      valueKey = _ref4.valueKey,\n      callback = _ref4.callback;\n  var activeIndex = getActiveIndex(focusItemValue, focusableItems, valueKey);\n\n  if (focusableItems.length === 0) {\n    return;\n  }\n\n  var prevIndex = activeIndex === 0 ? focusableItems.length - 1 : activeIndex - 1;\n  prevIndex = prevIndex >= 0 ? prevIndex : 0;\n  var prevFocusItemValue = focusableItems[prevIndex][valueKey];\n  callback === null || callback === void 0 ? void 0 : callback(prevFocusItemValue);\n  focusTreeNode(focusableItems[prevIndex].refKey, treeNodesRefs, selector);\n};\n\n/**\n * Left arrow keyboard event handler\n * When focus is on an open node, closes the node.\n * When focus is on a child node that is also either an end node or a closed node, moves focus to its parent node.\n * When focus is on a root node that is also either an end node or a closed node, does nothing.\n * @see https://www.w3.org/TR/wai-aria-practices/#TreeView\n */\nexport function leftArrowHandler(_ref5) {\n  var focusItem = _ref5.focusItem,\n      expand = _ref5.expand,\n      onExpand = _ref5.onExpand,\n      onFocusItem = _ref5.onFocusItem;\n\n  if (_isEmpty(focusItem)) {\n    return;\n  }\n\n  if (expand) {\n    onExpand(_extends({}, focusItem, {\n      expand: expand\n    }));\n  } else if (focusItem !== null && focusItem !== void 0 && focusItem.parent) {\n    onFocusItem();\n  }\n}\n/**\n * Right arrow keyboard event handler\n * When focus is on a closed node, opens the node; focus does not move.\n * When focus is on a open node, moves focus to the first child node.\n * When focus is on an end node, does nothing.\n * @see https://www.w3.org/TR/wai-aria-practices/#TreeView\n */\n\nexport function rightArrowHandler(_ref6) {\n  var focusItem = _ref6.focusItem,\n      expand = _ref6.expand,\n      childrenKey = _ref6.childrenKey,\n      onExpand = _ref6.onExpand,\n      onFocusItem = _ref6.onFocusItem;\n\n  if (_isEmpty(focusItem) || !Array.isArray(focusItem[childrenKey])) {\n    return;\n  }\n\n  if (!expand) {\n    onExpand(_extends({}, focusItem, {\n      expand: expand\n    }));\n  } else {\n    onFocusItem();\n  }\n}\n/**\n * get scrollIndex in virtualized list\n * @param nodes - data\n * @param value - activeItem value\n * @param valueKey\n */\n\nexport var getScrollToIndex = function getScrollToIndex(nodes, value, valueKey) {\n  return nodes.filter(function (n) {\n    return n.visible;\n  }).findIndex(function (item) {\n    return item[valueKey] === value;\n  });\n};\n/**\n * when searching, expand state always return true\n * @param searchKeyword\n * @param expand\n */\n\nexport function getExpandWhenSearching(searchKeyword, expand) {\n  return isSearching(searchKeyword) ? true : expand;\n}\n\nfunction getTreeActiveNode(nodes, value, valueKey) {\n  if (_isUndefined(value)) {\n    return undefined;\n  }\n\n  for (var refKey in nodes) {\n    if (shallowEqual(nodes[refKey][valueKey], value)) {\n      return nodes[refKey];\n    }\n  }\n}\n\nexport { getTreeActiveNode };\n/**\n * toggle tree node\n * @param param0\n */\n\nexport function toggleExpand(_ref7) {\n  var node = _ref7.node,\n      isExpand = _ref7.isExpand,\n      expandItemValues = _ref7.expandItemValues,\n      valueKey = _ref7.valueKey;\n  var newExpandItemValues = new Set(expandItemValues);\n\n  if (isExpand) {\n    newExpandItemValues.add(node[valueKey]);\n  } else {\n    newExpandItemValues.delete(node[valueKey]);\n  }\n\n  return Array.from(newExpandItemValues);\n}\nexport function getTreeNodeTitle(label) {\n  if (typeof label === 'string') {\n    return label;\n  } else if ( /*#__PURE__*/React.isValidElement(label)) {\n    var _nodes = reactToString(label);\n\n    return _nodes.join('');\n  }\n}\n/**\n * get all children from flattenNodes object by given parent node\n * @param nodes\n * @param parent\n */\n\nexport function getChildrenByFlattenNodes(nodes, parent) {\n  if (!_isNil(parent.refKey) && _isNil(nodes[parent.refKey])) {\n    return [];\n  }\n\n  return Object.values(nodes).filter(function (item) {\n    var _item$parent;\n\n    return (item === null || item === void 0 ? void 0 : (_item$parent = item.parent) === null || _item$parent === void 0 ? void 0 : _item$parent.refKey) === parent.refKey && item.refKey && !nodes[item.refKey].uncheckable;\n  });\n}\nexport function useTreeDrag() {\n  // current dragging node\n  var dragNode = useRef(null);\n\n  var _useState = useState(null),\n      dragOverNodeKey = _useState[0],\n      setDragOverNodeKey = _useState[1]; // drag node and it's children nodes key\n\n\n  var _useState2 = useState([]),\n      dragNodeKeys = _useState2[0],\n      setDragNodeKeys = _useState2[1];\n\n  var _useState3 = useState(null),\n      dropNodePosition = _useState3[0],\n      setDropNodePosition = _useState3[1];\n\n  var setDragNode = function setDragNode(node) {\n    dragNode.current = node;\n  };\n\n  return {\n    dragNode: dragNode === null || dragNode === void 0 ? void 0 : dragNode.current,\n    dragOverNodeKey: dragOverNodeKey,\n    dragNodeKeys: dragNodeKeys,\n    dropNodePosition: dropNodePosition,\n    setDragNode: setDragNode,\n    setDragOverNodeKey: setDragOverNodeKey,\n    setDragNodeKeys: setDragNodeKeys,\n    setDropNodePosition: setDropNodePosition\n  };\n}\n\n/**\n * hooks for flatten tree structure\n * @param param0\n */\nexport function useFlattenTreeData(_ref8) {\n  var data = _ref8.data,\n      labelKey = _ref8.labelKey,\n      valueKey = _ref8.valueKey,\n      childrenKey = _ref8.childrenKey,\n      _ref8$uncheckableItem = _ref8.uncheckableItemValues,\n      uncheckableItemValues = _ref8$uncheckableItem === void 0 ? [] : _ref8$uncheckableItem,\n      callback = _ref8.callback;\n\n  var _useState4 = useState(Object.create(null)),\n      dispatch = _useState4[1];\n\n  var forceUpdate = useCallback(function () {\n    dispatch(Object.create(null));\n  }, [dispatch]);\n  var flattenNodes = useRef({});\n  var flattenTreeData = useCallback(function (treeData, ref, parent, layer) {\n    if (layer === void 0) {\n      layer = 1;\n    }\n\n    if (!Array.isArray(treeData) || treeData.length === 0) {\n      return [];\n    }\n\n    treeData.map(function (node, index) {\n      var _extends2;\n\n      var refKey = ref + \"-\" + index;\n      node.refKey = refKey;\n      flattenNodes.current[refKey] = _extends((_extends2 = {\n        layer: layer\n      }, _extends2[labelKey] = node[labelKey], _extends2[valueKey] = node[valueKey], _extends2.uncheckable = uncheckableItemValues.some(function (value) {\n        return shallowEqual(node[valueKey], value);\n      }), _extends2), node);\n\n      if (parent) {\n        flattenNodes.current[refKey].parent = _omit(parent, 'parent', 'children');\n      }\n\n      flattenTreeData(node[childrenKey], refKey, node, layer + 1);\n    });\n    callback === null || callback === void 0 ? void 0 : callback(flattenNodes.current);\n  }, [childrenKey, valueKey, labelKey, callback, uncheckableItemValues]);\n  var serializeListOnlyParent = useCallback(function (nodes, key) {\n    var list = [];\n    Object.keys(nodes).forEach(function (refKey) {\n      var currentNode = nodes[refKey];\n\n      if (!_isNil(currentNode.parent) && !_isNil(currentNode.parent.refKey)) {\n        var parentNode = nodes[currentNode.parent.refKey];\n\n        if (currentNode[key]) {\n          if (!(parentNode !== null && parentNode !== void 0 && parentNode.checkAll)) {\n            list.push(nodes[refKey][valueKey]);\n          } else if (parentNode !== null && parentNode !== void 0 && parentNode.uncheckable) {\n            list.push(nodes[refKey][valueKey]);\n          }\n        }\n      } else {\n        if (currentNode[key]) {\n          list.push(nodes[refKey][valueKey]);\n        }\n      }\n    });\n    return list;\n  }, [valueKey]);\n  /**\n   * using in CheckTreePicker, to unSerializeList check property\n   */\n\n  var unSerializeList = useCallback(function (_ref9) {\n    var nodes = _ref9.nodes,\n        key = _ref9.key,\n        _ref9$value = _ref9.value,\n        value = _ref9$value === void 0 ? [] : _ref9$value,\n        cascade = _ref9.cascade,\n        uncheckableItemValues = _ref9.uncheckableItemValues;\n    // Reset values to false\n    Object.keys(nodes).forEach(function (refKey) {\n      var node = nodes[refKey];\n\n      if (cascade && !_isNil(node.parent) && !_isNil(node.parent.refKey)) {\n        node[key] = nodes[node.parent.refKey][key];\n      } else {\n        node[key] = false;\n      }\n\n      value.forEach(function (value) {\n        if (shallowEqual(nodes[refKey][valueKey], value) && !uncheckableItemValues.some(function (uncheckableValue) {\n          return shallowEqual(value, uncheckableValue);\n        })) {\n          nodes[refKey][key] = true;\n        }\n      });\n    });\n  }, [valueKey]);\n\n  var formatVirtualizedTreeData = function formatVirtualizedTreeData(nodes, data, expandItemValues, options) {\n    var cascade = options.cascade,\n        searchKeyword = options.searchKeyword;\n    return flattenTree(data, childrenKey, function (node) {\n      var formatted = {};\n      var curNode = nodes === null || nodes === void 0 ? void 0 : nodes[node.refKey];\n      var parentKeys = getNodeParentKeys(nodes, curNode, valueKey);\n      /**\n       * When using virtualized,\n       * if the parent node is collapsed, the child nodes should be hidden\n       * avoid component height calculation errors\n       */\n\n      var visible = curNode !== null && curNode !== void 0 && curNode.parent ? shouldShowNodeByParentExpanded(expandItemValues, parentKeys) : true;\n      /**\n       * when searching, every node default expand\n       * the node's visible should follow the original state\n       */\n\n      if (isSearching(searchKeyword)) {\n        visible = node.visible;\n      }\n\n      if (curNode) {\n        var checkState = !_isUndefined(cascade) ? getNodeCheckState({\n          node: curNode,\n          cascade: cascade,\n          nodes: nodes,\n          childrenKey: childrenKey\n        }) : undefined;\n        formatted = _extends({}, node, {\n          check: curNode.check,\n          uncheckable: curNode.uncheckable,\n          hasChildren: !!node[childrenKey],\n          layer: curNode.layer,\n          parent: curNode.parent,\n          checkState: checkState,\n          visible: visible\n        });\n      }\n\n      return formatted;\n    });\n  };\n\n  useEffect(function () {\n    // when data is changed, should clear the flattenNodes, avoid duplicate keys\n    flattenNodes.current = {};\n    flattenTreeData(data, '0');\n  }, [data]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return {\n    forceUpdate: forceUpdate,\n    flattenNodes: flattenNodes.current,\n    flattenTreeData: flattenTreeData,\n    serializeListOnlyParent: serializeListOnlyParent,\n    unSerializeList: unSerializeList,\n    formatVirtualizedTreeData: formatVirtualizedTreeData\n  };\n}\n/**\n * A hook that saving every tree node ref\n */\n\nexport function useTreeNodeRefs() {\n  var treeNodeRefs = useRef({});\n\n  var saveTreeNodeRef = function saveTreeNodeRef(ref, refKey) {\n    if (!_isNil(refKey)) {\n      treeNodeRefs.current[refKey] = ref;\n    }\n  };\n\n  return {\n    treeNodesRefs: treeNodeRefs.current,\n    saveTreeNodeRef: saveTreeNodeRef\n  };\n}\n\n/**\n * A hook that handles tree search filter options\n * @param props\n */\nexport function useTreeSearch(props) {\n  var labelKey = props.labelKey,\n      childrenKey = props.childrenKey,\n      searchKeyword = props.searchKeyword,\n      data = props.data,\n      searchBy = props.searchBy,\n      callback = props.callback;\n  var filterVisibleData = useCallback(function (data, searchKeyword) {\n    var setVisible = function setVisible(nodes) {\n      return nodes.forEach(function (item) {\n        item.visible = searchBy ? searchBy(searchKeyword, item[labelKey], item) : shouldDisplay(item[labelKey], searchKeyword);\n\n        if (_isArray(item[childrenKey])) {\n          filterVisibleData(item[childrenKey], searchKeyword);\n          item[childrenKey].forEach(function (child) {\n            if (child.visible) {\n              item.visible = child.visible;\n            }\n          });\n        }\n      });\n    };\n\n    setVisible(data);\n    return data;\n  }, [childrenKey, labelKey, searchBy]); // Use search keywords to filter options.\n\n  var _useState5 = useState(function () {\n    return searchKeyword !== null && searchKeyword !== void 0 ? searchKeyword : '';\n  }),\n      searchKeywordState = _useState5[0],\n      setSearchKeyword = _useState5[1];\n\n  var _useState6 = useState(function () {\n    return filterVisibleData(data, searchKeywordState);\n  }),\n      filteredData = _useState6[0],\n      setFilteredData = _useState6[1];\n\n  var handleSetFilteredData = useCallback(function (data, searchKeyword) {\n    setFilteredData(filterVisibleData(data, searchKeyword));\n  }, [filterVisibleData]);\n\n  var handleSearch = function handleSearch(searchKeyword, event) {\n    var filteredData = filterVisibleData(data, searchKeyword);\n    setFilteredData(filteredData);\n    setSearchKeyword(searchKeyword);\n    callback === null || callback === void 0 ? void 0 : callback(searchKeyword, filteredData, event);\n  };\n\n  return {\n    searchKeywordState: searchKeywordState,\n    filteredData: filteredData,\n    setFilteredData: handleSetFilteredData,\n    setSearchKeyword: setSearchKeyword,\n    handleSearch: handleSearch\n  };\n}\nexport function useGetTreeNodeChildren(treeData, valueKey, childrenKey) {\n  var _useState7 = useState([]),\n      loadingNodeValues = _useState7[0],\n      setLoadingNodeValues = _useState7[1];\n\n  var _useState8 = useState(treeData),\n      data = _useState8[0],\n      setData = _useState8[1];\n\n  var concatChildren = useCallback(function (treeNode, children) {\n    var value = treeNode[valueKey];\n    treeNode = findNodeOfTree(data, function (item) {\n      return value === item[valueKey];\n    });\n    treeNode[childrenKey] = children;\n    var newData = data.concat([]);\n    setData(newData);\n    return newData;\n  }, [data, valueKey, childrenKey]);\n  var loadChildren = useCallback(function (node, getChildren) {\n    setLoadingNodeValues(function (prev) {\n      return prev.concat(node[valueKey]);\n    });\n    var children = getChildren(node);\n\n    if (children instanceof Promise) {\n      children.then(function (res) {\n        var newData = concatChildren(node, res);\n        setData(newData);\n        setLoadingNodeValues(function (prev) {\n          return prev.filter(function (item) {\n            return !shallowEqual(item, node[valueKey]);\n          });\n        });\n      });\n    } else {\n      setData(concatChildren(node, children));\n      setLoadingNodeValues(function (prev) {\n        return prev.filter(function (item) {\n          return !shallowEqual(item, node[valueKey]);\n        });\n      });\n    }\n  }, [concatChildren, valueKey]);\n  return {\n    data: data,\n    setData: setData,\n    loadingNodeValues: loadingNodeValues,\n    loadChildren: loadChildren\n  };\n}\n\n/**\n * Focus to active tree node.\n * @param param0\n */\nexport function focusToActiveTreeNode(_ref10) {\n  var _activeItem$focus;\n\n  var list = _ref10.list,\n      valueKey = _ref10.valueKey,\n      activeNode = _ref10.activeNode,\n      virtualized = _ref10.virtualized,\n      container = _ref10.container,\n      selector = _ref10.selector,\n      formattedNodes = _ref10.formattedNodes;\n  if (!container) return;\n\n  if (virtualized && activeNode) {\n    var _list$scrollToRow;\n\n    var scrollIndex = getScrollToIndex(formattedNodes, activeNode === null || activeNode === void 0 ? void 0 : activeNode[valueKey], valueKey);\n    (_list$scrollToRow = list.scrollToRow) === null || _list$scrollToRow === void 0 ? void 0 : _list$scrollToRow.call(list, scrollIndex);\n    return;\n  }\n\n  var activeItem = container.querySelector(selector);\n\n  if (!activeItem) {\n    return;\n  }\n\n  activeItem === null || activeItem === void 0 ? void 0 : (_activeItem$focus = activeItem.focus) === null || _activeItem$focus === void 0 ? void 0 : _activeItem$focus.call(activeItem);\n}\nexport function isSearching(searchKeyword) {\n  return !_isEmpty(searchKeyword);\n}\nexport function getTreeNodeIndent(rtl, layer, absolute) {\n  var _ref12;\n\n  if (absolute === void 0) {\n    absolute = false;\n  }\n\n  // layer start from 1\n  var offset = layer * TREE_NODE_PADDING + TREE_NODE_ROOT_PADDING;\n\n  if (absolute) {\n    var _ref11;\n\n    return _ref11 = {}, _ref11[rtl ? 'right' : 'left'] = offset, _ref11;\n  }\n\n  return _ref12 = {}, _ref12[rtl ? 'paddingRight' : 'paddingLeft'] = offset, _ref12;\n}"]},"metadata":{},"sourceType":"module"}