{"ast":null,"code":"import _defineProperty from \"E:/React/pos-system/main/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"E:/React/pos-system/main/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nvar _excluded = [\"stateId\"];\nimport * as React from 'react';\nimport { GridSignature } from '../utils/useGridApiEventHandler';\nimport { useGridApiMethod } from '../utils';\nimport { isFunction } from '../../utils/utils';\nexport var useGridStateInitialization = function useGridStateInitialization(apiRef, props) {\n  var controlStateMapRef = React.useRef({});\n\n  var _React$useState = React.useState(),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      rawForceUpdate = _React$useState2[1];\n\n  var registerControlState = React.useCallback(function (controlStateItem) {\n    var stateId = controlStateItem.stateId,\n        others = _objectWithoutPropertiesLoose(controlStateItem, _excluded);\n\n    controlStateMapRef.current[stateId] = _extends({}, others, {\n      stateId: stateId\n    });\n  }, []);\n  var setState = React.useCallback(function (state, reason) {\n    var newState;\n\n    if (isFunction(state)) {\n      newState = state(apiRef.current.state);\n    } else {\n      newState = state;\n    }\n\n    if (apiRef.current.state === newState) {\n      return false;\n    }\n\n    var ignoreSetState = false; // Apply the control state constraints\n\n    var updatedControlStateIds = [];\n    Object.keys(controlStateMapRef.current).forEach(function (stateId) {\n      var controlState = controlStateMapRef.current[stateId];\n      var oldSubState = controlState.stateSelector(apiRef.current.state, apiRef.current.instanceId);\n      var newSubState = controlState.stateSelector(newState, apiRef.current.instanceId);\n\n      if (newSubState === oldSubState) {\n        return;\n      }\n\n      updatedControlStateIds.push({\n        stateId: controlState.stateId,\n        hasPropChanged: newSubState !== controlState.propModel\n      }); // The state is controlled, the prop should always win\n\n      if (controlState.propModel !== undefined && newSubState !== controlState.propModel) {\n        ignoreSetState = true;\n      }\n    });\n\n    if (updatedControlStateIds.length > 1) {\n      // Each hook modify its own state, and it should not leak\n      // Events are here to forward to other hooks and apply changes.\n      // You are trying to update several states in a no isolated way.\n      throw new Error(\"You're not allowed to update several sub-state in one transaction. You already updated \".concat(updatedControlStateIds[0].stateId, \", therefore, you're not allowed to update \").concat(updatedControlStateIds.map(function (el) {\n        return el.stateId;\n      }).join(', '), \" in the same transaction.\"));\n    }\n\n    if (!ignoreSetState) {\n      // We always assign it as we mutate rows for perf reason.\n      apiRef.current.state = newState;\n\n      if (apiRef.current.publishEvent) {\n        apiRef.current.publishEvent('stateChange', newState);\n      }\n    }\n\n    if (updatedControlStateIds.length === 1) {\n      var _updatedControlStateI = updatedControlStateIds[0],\n          stateId = _updatedControlStateI.stateId,\n          hasPropChanged = _updatedControlStateI.hasPropChanged;\n      var controlState = controlStateMapRef.current[stateId];\n      var model = controlState.stateSelector(newState, apiRef.current.instanceId);\n\n      if (controlState.propOnChange && hasPropChanged) {\n        var details = props.signature === GridSignature.DataGridPro ? {\n          api: apiRef.current,\n          reason: reason\n        } : {\n          reason: reason\n        };\n        controlState.propOnChange(model, details);\n      }\n\n      if (!ignoreSetState) {\n        apiRef.current.publishEvent(controlState.changeEvent, model, {\n          reason: reason\n        });\n      }\n    }\n\n    return !ignoreSetState;\n  }, [apiRef, props.signature]);\n  var updateControlState = React.useCallback(function (key, state, reason) {\n    return apiRef.current.setState(function (previousState) {\n      return _extends({}, previousState, _defineProperty({}, key, state(previousState[key])));\n    }, reason);\n  }, [apiRef]);\n  var forceUpdate = React.useCallback(function () {\n    return rawForceUpdate(function () {\n      return apiRef.current.state;\n    });\n  }, [apiRef]);\n  var stateApi = {\n    setState: setState,\n    forceUpdate: forceUpdate,\n    unstable_updateControlState: updateControlState,\n    unstable_registerControlState: registerControlState\n  };\n  useGridApiMethod(apiRef, stateApi, 'GridStateApi');\n};","map":{"version":3,"sources":["E:/React/pos-system/main/node_modules/@mui/x-data-grid/hooks/core/useGridStateInitialization.js"],"names":["_extends","_objectWithoutPropertiesLoose","_excluded","React","GridSignature","useGridApiMethod","isFunction","useGridStateInitialization","apiRef","props","controlStateMapRef","useRef","useState","rawForceUpdate","registerControlState","useCallback","controlStateItem","stateId","others","current","setState","state","reason","newState","ignoreSetState","updatedControlStateIds","Object","keys","forEach","controlState","oldSubState","stateSelector","instanceId","newSubState","push","hasPropChanged","propModel","undefined","length","Error","map","el","join","publishEvent","model","propOnChange","details","signature","DataGridPro","api","changeEvent","updateControlState","key","previousState","forceUpdate","stateApi","unstable_updateControlState","unstable_registerControlState"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"stateId\"];\nimport * as React from 'react';\nimport { GridSignature } from '../utils/useGridApiEventHandler';\nimport { useGridApiMethod } from '../utils';\nimport { isFunction } from '../../utils/utils';\nexport const useGridStateInitialization = (apiRef, props) => {\n  const controlStateMapRef = React.useRef({});\n  const [, rawForceUpdate] = React.useState();\n  const registerControlState = React.useCallback(controlStateItem => {\n    const {\n      stateId\n    } = controlStateItem,\n          others = _objectWithoutPropertiesLoose(controlStateItem, _excluded);\n\n    controlStateMapRef.current[stateId] = _extends({}, others, {\n      stateId\n    });\n  }, []);\n  const setState = React.useCallback((state, reason) => {\n    let newState;\n\n    if (isFunction(state)) {\n      newState = state(apiRef.current.state);\n    } else {\n      newState = state;\n    }\n\n    if (apiRef.current.state === newState) {\n      return false;\n    }\n\n    let ignoreSetState = false; // Apply the control state constraints\n\n    const updatedControlStateIds = [];\n    Object.keys(controlStateMapRef.current).forEach(stateId => {\n      const controlState = controlStateMapRef.current[stateId];\n      const oldSubState = controlState.stateSelector(apiRef.current.state, apiRef.current.instanceId);\n      const newSubState = controlState.stateSelector(newState, apiRef.current.instanceId);\n\n      if (newSubState === oldSubState) {\n        return;\n      }\n\n      updatedControlStateIds.push({\n        stateId: controlState.stateId,\n        hasPropChanged: newSubState !== controlState.propModel\n      }); // The state is controlled, the prop should always win\n\n      if (controlState.propModel !== undefined && newSubState !== controlState.propModel) {\n        ignoreSetState = true;\n      }\n    });\n\n    if (updatedControlStateIds.length > 1) {\n      // Each hook modify its own state, and it should not leak\n      // Events are here to forward to other hooks and apply changes.\n      // You are trying to update several states in a no isolated way.\n      throw new Error(`You're not allowed to update several sub-state in one transaction. You already updated ${updatedControlStateIds[0].stateId}, therefore, you're not allowed to update ${updatedControlStateIds.map(el => el.stateId).join(', ')} in the same transaction.`);\n    }\n\n    if (!ignoreSetState) {\n      // We always assign it as we mutate rows for perf reason.\n      apiRef.current.state = newState;\n\n      if (apiRef.current.publishEvent) {\n        apiRef.current.publishEvent('stateChange', newState);\n      }\n    }\n\n    if (updatedControlStateIds.length === 1) {\n      const {\n        stateId,\n        hasPropChanged\n      } = updatedControlStateIds[0];\n      const controlState = controlStateMapRef.current[stateId];\n      const model = controlState.stateSelector(newState, apiRef.current.instanceId);\n\n      if (controlState.propOnChange && hasPropChanged) {\n        const details = props.signature === GridSignature.DataGridPro ? {\n          api: apiRef.current,\n          reason\n        } : {\n          reason\n        };\n        controlState.propOnChange(model, details);\n      }\n\n      if (!ignoreSetState) {\n        apiRef.current.publishEvent(controlState.changeEvent, model, {\n          reason\n        });\n      }\n    }\n\n    return !ignoreSetState;\n  }, [apiRef, props.signature]);\n  const updateControlState = React.useCallback((key, state, reason) => {\n    return apiRef.current.setState(previousState => {\n      return _extends({}, previousState, {\n        [key]: state(previousState[key])\n      });\n    }, reason);\n  }, [apiRef]);\n  const forceUpdate = React.useCallback(() => rawForceUpdate(() => apiRef.current.state), [apiRef]);\n  const stateApi = {\n    setState,\n    forceUpdate,\n    unstable_updateControlState: updateControlState,\n    unstable_registerControlState: registerControlState\n  };\n  useGridApiMethod(apiRef, stateApi, 'GridStateApi');\n};"]},"metadata":{},"sourceType":"module"}