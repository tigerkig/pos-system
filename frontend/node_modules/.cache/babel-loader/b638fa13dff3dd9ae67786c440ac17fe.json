{"ast":null,"code":"/*\r\n * wysiwyg web editor\r\n *\r\n * suneditor.js\r\n * Copyright 2017 JiHong Lee.\r\n * MIT license.\r\n */\n'use strict';\n/**\r\n * @description utility function\r\n */\n\nvar util = {\n  _d: null,\n  _w: null,\n  isIE: null,\n  isIE_Edge: null,\n  isOSX_IOS: null,\n  isChromium: null,\n  _propertiesInit: function _propertiesInit() {\n    if (this._d) return;\n    this._d = document;\n    this._w = window;\n    this.isIE = navigator.userAgent.indexOf('Trident') > -1;\n    this.isIE_Edge = navigator.userAgent.indexOf('Trident') > -1 || navigator.appVersion.indexOf('Edge') > -1;\n    this.isOSX_IOS = /(Mac|iPhone|iPod|iPad)/.test(navigator.platform);\n    this.isChromium = !!window.chrome;\n  },\n  _allowedEmptyNodeList: '.se-component, pre, blockquote, hr, li, table, img, iframe, video, audio, canvas',\n\n  /**\r\n   * @description HTML Reserved Word Converter.\r\n   * @param {String} contents \r\n   * @returns {String} HTML string\r\n   * @private\r\n   */\n  _HTMLConvertor: function _HTMLConvertor(contents) {\n    var ec = {\n      '&': '&amp;',\n      \"\\xA0\": '&nbsp;',\n      '\\'': '&apos;',\n      '\"': '&quot;',\n      '<': '&lt;',\n      '>': '&gt;'\n    };\n    return contents.replace(/&|\\u00A0|'|\"|<|>/g, function (m) {\n      return typeof ec[m] === 'string' ? ec[m] : m;\n    });\n  },\n\n  /**\r\n   * @description Unicode Character 'ZERO WIDTH SPACE' (\\u200B)\r\n   */\n  zeroWidthSpace: String.fromCharCode(8203),\n\n  /**\r\n   * @description Regular expression to find 'zero width space' (/\\u200B/g)\r\n   */\n  zeroWidthRegExp: new RegExp(String.fromCharCode(8203), 'g'),\n\n  /**\r\n   * @description Regular expression to find only 'zero width space' (/^\\u200B+$/)\r\n   */\n  onlyZeroWidthRegExp: new RegExp('^' + String.fromCharCode(8203) + '+$'),\n\n  /**\r\n   * @description A method that checks If the text is blank or to see if it contains 'ZERO WIDTH SPACE' or empty (util.zeroWidthSpace)\r\n   * @param {String|Node} text String value or Node\r\n   * @returns {Boolean}\r\n   */\n  onlyZeroWidthSpace: function onlyZeroWidthSpace(text) {\n    if (text === null || text === undefined) return false;\n    if (typeof text !== 'string') text = text.textContent;\n    return text === '' || this.onlyZeroWidthRegExp.test(text);\n  },\n\n  /**\r\n   * @description Gets XMLHttpRequest object\r\n   * @returns {XMLHttpRequest|ActiveXObject}\r\n   */\n  getXMLHttpRequest: function getXMLHttpRequest() {\n    /** IE */\n    if (this._w.ActiveXObject) {\n      try {\n        return new ActiveXObject('Msxml2.XMLHTTP');\n      } catch (e) {\n        try {\n          return new ActiveXObject('Microsoft.XMLHTTP');\n        } catch (e1) {\n          return null;\n        }\n      }\n    }\n    /** netscape */\n    else if (this._w.XMLHttpRequest) {\n      return new XMLHttpRequest();\n    }\n    /** fail */\n    else {\n      return null;\n    }\n  },\n\n  /**\r\n   * @description Object.values\r\n   * @param {Object|null} obj Object parameter.\r\n   * @returns {Array}\r\n   */\n  getValues: function getValues(obj) {\n    return !obj ? [] : this._w.Object.keys(obj).map(function (i) {\n      return obj[i];\n    });\n  },\n\n  /**\r\n   * @description Convert the CamelCase To the KebabCase.\r\n   * @param {String|Array} param [Camel string]\r\n   * @returns {String|Array}\r\n   */\n  camelToKebabCase: function camelToKebabCase(param) {\n    if (typeof param === 'string') {\n      return param.replace(/[A-Z]/g, function (letter) {\n        return \"-\" + letter.toLowerCase();\n      });\n    } else {\n      return param.map(function (str) {\n        return util.camelToKebabCase(str);\n      });\n    }\n  },\n\n  /**\r\n   * @description Convert the KebabCase To the CamelCase.\r\n   * @param {String|Array} param [KebabCase string]\r\n   * @returns {String|Array}\r\n   */\n  kebabToCamelCase: function kebabToCamelCase(param) {\n    if (typeof param === 'string') {\n      return param.replace(/-[a-zA-Z]/g, function (letter) {\n        return letter.replace('-', '').toUpperCase();\n      });\n    } else {\n      return param.map(function (str) {\n        return util.camelToKebabCase(str);\n      });\n    }\n  },\n\n  /**\r\n   * @description Create Element node\r\n   * @param {String} elementName Element name\r\n   * @returns {Element}\r\n   */\n  createElement: function createElement(elementName) {\n    return this._d.createElement(elementName);\n  },\n\n  /**\r\n   * @description Create text node\r\n   * @param {String} text text contents\r\n   * @returns {Node}\r\n   */\n  createTextNode: function createTextNode(text) {\n    return this._d.createTextNode(text || '');\n  },\n\n  /**\r\n   * @description The editor checks tags by string.\r\n   * If there is \"<\" or \">\" in the attribute of tag, HTML is broken when checking the tag.\r\n   * When using an attribute with \"<\" or \">\", use \"HTMLEncoder\" to save. (ex: math(katex))\r\n   * @param {String} contents HTML or Text string\r\n   * @returns {String}\r\n   */\n  HTMLEncoder: function HTMLEncoder(contents) {\n    var ec = {\n      '<': '$lt;',\n      '>': '$gt;'\n    };\n    return contents.replace(/<|>/g, function (m) {\n      return typeof ec[m] === 'string' ? ec[m] : m;\n    });\n  },\n\n  /**\r\n   * @description The editor checks tags by string.\r\n   * If there is \"<\" or \">\" in the attribute of tag, HTML is broken when checking the tag.\r\n   * Decoder of data stored as \"HTMLEncoder\" (ex: math(katex))\r\n   * @param {String} contents HTML or Text string\r\n   * @returns {String}\r\n   */\n  HTMLDecoder: function HTMLDecoder(contents) {\n    var ec = {\n      '$lt;': '<',\n      '$gt;': '>'\n    };\n    return contents.replace(/\\$lt;|\\$gt;/g, function (m) {\n      return typeof ec[m] === 'string' ? ec[m] : m;\n    });\n  },\n\n  /**\r\n   * @description This method run Object.prototype.hasOwnProperty.call(obj, key)\r\n   * @param {Object} obj Object\r\n   * @param {String} key obj.key\r\n   * @returns {Boolean}\r\n   */\n  hasOwn: function hasOwn(obj, key) {\n    return this._hasOwn.call(obj, key);\n  },\n  _hasOwn: Object.prototype.hasOwnProperty,\n\n  /**\r\n   * @deprecated\r\n   * @description Get the the tag path of the arguments value\r\n   * If not found, return the first found value\r\n   * @param {Array} nameArray File name array\r\n   * @param {String} extension js, css\r\n   * @returns {String}\r\n   */\n  getIncludePath: function getIncludePath(nameArray, extension) {\n    var path = '';\n    var pathList = [];\n    var tagName = extension === 'js' ? 'script' : 'link';\n    var src = extension === 'js' ? 'src' : 'href';\n    var fileName = '(?:';\n\n    for (var i = 0, len = nameArray.length; i < len; i++) {\n      fileName += nameArray[i] + (i < len - 1 ? '|' : ')');\n    }\n\n    var regExp = new this._w.RegExp('(^|.*[\\\\/])' + fileName + '(\\\\.[^\\\\/]+)?\\.' + extension + '(?:\\\\?.*|;.*)?$', 'i');\n    var extRegExp = new this._w.RegExp('.+\\\\.' + extension + '(?:\\\\?.*|;.*)?$', 'i');\n\n    for (var c = this._d.getElementsByTagName(tagName), _i = 0; _i < c.length; _i++) {\n      if (extRegExp.test(c[_i][src])) {\n        pathList.push(c[_i]);\n      }\n    }\n\n    for (var _i2 = 0; _i2 < pathList.length; _i2++) {\n      var editorTag = pathList[_i2][src].match(regExp);\n\n      if (editorTag) {\n        path = editorTag[0];\n        break;\n      }\n    }\n\n    if (path === '') path = pathList.length > 0 ? pathList[0][src] : '';\n    -1 === path.indexOf(':/') && '//' !== path.slice(0, 2) && (path = 0 === path.indexOf('/') ? location.href.match(/^.*?:\\/\\/[^\\/]*/)[0] + path : location.href.match(/^[^\\?]*\\/(?:)/)[0] + path);\n    if (!path) throw '[SUNEDITOR.util.getIncludePath.fail] The SUNEDITOR installation path could not be automatically detected. (name: +' + name + ', extension: ' + extension + ')';\n    return path;\n  },\n\n  /**\r\n   * @deprecated\r\n   * @description Returns the CSS text that has been applied to the current page.\r\n   * @param {Document|null} doc To get the CSS text of an document(core._wd). If null get the current document.\r\n   * @returns {String} Styles string\r\n   */\n  getPageStyle: function getPageStyle(doc) {\n    var cssText = '';\n    var sheets = (doc || this._d).styleSheets;\n\n    for (var i = 0, len = sheets.length, rules; i < len; i++) {\n      try {\n        rules = sheets[i].cssRules;\n      } catch (e) {\n        continue;\n      }\n\n      if (rules) {\n        for (var c = 0, cLen = rules.length; c < cLen; c++) {\n          cssText += rules[c].cssText;\n        }\n      }\n    }\n\n    return cssText;\n  },\n\n  /**\r\n   * @description Get the argument iframe's document object\r\n   * @param {Element} iframe Iframe element (context.element.wysiwygFrame)\r\n   * @returns {Document}\r\n   */\n  getIframeDocument: function getIframeDocument(iframe) {\n    var wDocument = iframe.contentWindow || iframe.contentDocument;\n    if (wDocument.document) wDocument = wDocument.document;\n    return wDocument;\n  },\n\n  /**\r\n   * @description Get attributes of argument element to string ('class=\"---\" name=\"---\" ')\r\n   * @param {Element} element Element object\r\n   * @param {Array|null} exceptAttrs Array of attribute names to exclude from the result\r\n   * @returns {String}\r\n   */\n  getAttributesToString: function getAttributesToString(element, exceptAttrs) {\n    if (!element.attributes) return '';\n    var attrs = element.attributes;\n    var attrString = '';\n\n    for (var i = 0, len = attrs.length; i < len; i++) {\n      if (exceptAttrs && exceptAttrs.indexOf(attrs[i].name) > -1) continue;\n      attrString += attrs[i].name + '=\"' + attrs[i].value + '\" ';\n    }\n\n    return attrString;\n  },\n\n  /**\r\n   * @descriptionGets Get the length in bytes of a string.\r\n   * referencing code: \"https://github.com/shaan1974/myrdin/blob/master/expressions/string.js#L11\"\r\n   * @param {String} text String text\r\n   * @returns {Number}\r\n   */\n  getByteLength: function getByteLength(text) {\n    if (!text || !text.toString) return 0;\n    text = text.toString();\n    var encoder = this._w.encodeURIComponent;\n    var cr, cl;\n\n    if (this.isIE_Edge) {\n      cl = this._w.unescape(encoder(text)).length;\n      cr = 0;\n\n      if (encoder(text).match(/(%0A|%0D)/gi) !== null) {\n        cr = encoder(text).match(/(%0A|%0D)/gi).length;\n      }\n\n      return cl + cr;\n    } else {\n      cl = new this._w.TextEncoder('utf-8').encode(text).length;\n      cr = 0;\n\n      if (encoder(text).match(/(%0A|%0D)/gi) !== null) {\n        cr = encoder(text).match(/(%0A|%0D)/gi).length;\n      }\n\n      return cl + cr;\n    }\n  },\n\n  /**\r\n   * @description It is judged whether it is the edit region top div element or iframe's body tag.\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isWysiwygDiv: function isWysiwygDiv(element) {\n    return element && element.nodeType === 1 && (this.hasClass(element, 'se-wrapper-wysiwyg') || /^BODY$/i.test(element.nodeName));\n  },\n\n  /**\r\n   * @description It is judged whether it is the contenteditable property is false.\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isNonEditable: function isNonEditable(element) {\n    return element && element.nodeType === 1 && element.getAttribute('contenteditable') === 'false';\n  },\n\n  /**\r\n   * @description It is judged whether it is a node related to the text style.\r\n   * (strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code)\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isTextStyleElement: function isTextStyleElement(element) {\n    return element && element.nodeType !== 3 && /^(strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code|summary)$/i.test(element.nodeName);\n  },\n\n  /**\r\n   * @description It is judged whether it is the format element (P, DIV, H[1-6], PRE, LI | class=\"__se__format__replace_xxx\")\r\n   * Format element also contain \"free format Element\"\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isFormatElement: function isFormatElement(element) {\n    return element && element.nodeType === 1 && (/^(P|DIV|H[1-6]|PRE|LI|TH|TD|DETAILS)$/i.test(element.nodeName) || this.hasClass(element, '(\\\\s|^)__se__format__replace_.+(\\\\s|$)|(\\\\s|^)__se__format__free_.+(\\\\s|$)')) && !this.isComponent(element) && !this.isWysiwygDiv(element);\n  },\n\n  /**\r\n   * @description It is judged whether it is the range format element. (BLOCKQUOTE, OL, UL, FIGCAPTION, TABLE, THEAD, TBODY, TR, TH, TD | class=\"__se__format__range_xxx\")\r\n   * Range format element is wrap the \"format element\" and \"component\"\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isRangeFormatElement: function isRangeFormatElement(element) {\n    return element && element.nodeType === 1 && (/^(BLOCKQUOTE|OL|UL|FIGCAPTION|TABLE|THEAD|TBODY|TR|TH|TD|DETAILS)$/i.test(element.nodeName) || this.hasClass(element, '(\\\\s|^)__se__format__range_.+(\\\\s|$)'));\n  },\n\n  /**\r\n   * @description It is judged whether it is the closure range format element. (TH, TD | class=\"__se__format__range__closure_xxx\")\r\n   * Closure range format elements is included in the range format element.\r\n   *  - Closure range format element is wrap the \"format element\" and \"component\"\r\n   * ※ You cannot exit this format with the Enter key or Backspace key.\r\n   * ※ Use it only in special cases. ([ex] format of table cells)\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isClosureRangeFormatElement: function isClosureRangeFormatElement(element) {\n    return element && element.nodeType === 1 && (/^(TH|TD)$/i.test(element.nodeName) || this.hasClass(element, '(\\\\s|^)__se__format__range__closure_.+(\\\\s|$)'));\n  },\n\n  /**\r\n   * @description It is judged whether it is the free format element. (PRE | class=\"__se__format__free_xxx\")\r\n   * Free format elements is included in the format element.\r\n   * Free format elements's line break is \"BR\" tag.\r\n   * ※ Entering the Enter key in the space on the last line ends \"Free Format\" and appends \"Format\".\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isFreeFormatElement: function isFreeFormatElement(element) {\n    return element && element.nodeType === 1 && (/^PRE$/i.test(element.nodeName) || this.hasClass(element, '(\\\\s|^)__se__format__free_.+(\\\\s|$)')) && !this.isComponent(element) && !this.isWysiwygDiv(element);\n  },\n\n  /**\r\n   * @description It is judged whether it is the closure free format element. (class=\"__se__format__free__closure_xxx\")\r\n   * Closure free format elements is included in the free format element.\r\n   *  - Closure free format elements's line break is \"BR\" tag.\r\n   * ※ You cannot exit this format with the Enter key or Backspace key.\r\n   * ※ Use it only in special cases. ([ex] format of table cells)\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isClosureFreeFormatElement: function isClosureFreeFormatElement(element) {\n    return element && element.nodeType === 1 && this.hasClass(element, '(\\\\s|^)__se__format__free__closure_.+(\\\\s|$)');\n  },\n\n  /**\r\n   * @description It is judged whether it is the component[img, iframe, video, audio, table] cover(class=\"se-component\") and table, hr\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isComponent: function isComponent(element) {\n    return element && (/se-component/.test(element.className) || /^(TABLE|HR)$/.test(element.nodeName));\n  },\n\n  /**\r\n   * @description Checks for \"__se__uneditable\" in the class list.\r\n   * Components with class \"__se__uneditable\" cannot be modified.\r\n   * @param {Element} element The element to check\r\n   * @returns {Boolean}\r\n   */\n  isUneditableComponent: function isUneditableComponent(element) {\n    return element && this.hasClass(element, '__se__uneditable');\n  },\n\n  /**\r\n   * @description It is judged whether it is the component [img, iframe] cover(class=\"se-component\")\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isMediaComponent: function isMediaComponent(element) {\n    return element && /se-component/.test(element.className);\n  },\n\n  /**\r\n   * @description It is judged whether it is the not checking node. (class=\"katex\", \"__se__tag\")\r\n   * @param {Node} element The node to check\r\n   * @returns {Boolean}\r\n   */\n  isNotCheckingNode: function isNotCheckingNode(element) {\n    return element && /katex|__se__tag/.test(element.className);\n  },\n\n  /**\r\n   * @description If a parent node that contains an argument node finds a format node (util.isFormatElement), it returns that node.\r\n   * @param {Node} element Reference node.\r\n   * @param {Function|null} validation Additional validation function.\r\n   * @returns {Element|null}\r\n   */\n  getFormatElement: function getFormatElement(element, validation) {\n    if (!element) return null;\n\n    if (!validation) {\n      validation = function validation() {\n        return true;\n      };\n    }\n\n    while (element) {\n      if (this.isWysiwygDiv(element)) return null;\n      if (this.isRangeFormatElement(element)) element.firstElementChild;\n      if (this.isFormatElement(element) && validation(element)) return element;\n      element = element.parentNode;\n    }\n\n    return null;\n  },\n\n  /**\r\n   * @description If a parent node that contains an argument node finds a format node (util.isRangeFormatElement), it returns that node.\r\n   * @param {Node} element Reference node.\r\n   * @param {Function|null} validation Additional validation function.\r\n   * @returns {Element|null}\r\n   */\n  getRangeFormatElement: function getRangeFormatElement(element, validation) {\n    if (!element) return null;\n\n    if (!validation) {\n      validation = function validation() {\n        return true;\n      };\n    }\n\n    while (element) {\n      if (this.isWysiwygDiv(element)) return null;\n      if (this.isRangeFormatElement(element) && !/^(THEAD|TBODY|TR)$/i.test(element.nodeName) && validation(element)) return element;\n      element = element.parentNode;\n    }\n\n    return null;\n  },\n\n  /**\r\n   * @description If a parent node that contains an argument node finds a free format node (util.isFreeFormatElement), it returns that node.\r\n   * @param {Node} element Reference node.\r\n   * @param {Function|null} validation Additional validation function.\r\n   * @returns {Element|null}\r\n   */\n  getFreeFormatElement: function getFreeFormatElement(element, validation) {\n    if (!element) return null;\n\n    if (!validation) {\n      validation = function validation() {\n        return true;\n      };\n    }\n\n    while (element) {\n      if (this.isWysiwygDiv(element)) return null;\n      if (this.isFreeFormatElement(element) && validation(element)) return element;\n      element = element.parentNode;\n    }\n\n    return null;\n  },\n\n  /**\r\n   * @description If a parent node that contains an argument node finds a closure free format node (util.isClosureFreeFormatElement), it returns that node.\r\n   * @param {Node} element Reference node.\r\n   * @param {Function|null} validation Additional validation function.\r\n   * @returns {Element|null}\r\n   */\n  getClosureFreeFormatElement: function getClosureFreeFormatElement(element, validation) {\n    if (!element) return null;\n\n    if (!validation) {\n      validation = function validation() {\n        return true;\n      };\n    }\n\n    while (element) {\n      if (this.isWysiwygDiv(element)) return null;\n      if (this.isClosureFreeFormatElement(element) && validation(element)) return element;\n      element = element.parentNode;\n    }\n\n    return null;\n  },\n\n  /**\r\n   * @description Add style and className of copyEl to originEl\r\n   * @param {Element} originEl Origin element\r\n   * @param {Element} copyEl Element to copy\r\n   */\n  copyTagAttributes: function copyTagAttributes(originEl, copyEl) {\n    if (copyEl.style.cssText) {\n      originEl.style.cssText += copyEl.style.cssText;\n    }\n\n    var classes = copyEl.classList;\n\n    for (var i = 0, len = classes.length; i < len; i++) {\n      this.addClass(originEl, classes[i]);\n    }\n\n    if (!originEl.style.cssText) originEl.removeAttribute('style');\n    if (!originEl.className.trim()) originEl.removeAttribute('class');\n  },\n\n  /**\r\n   * @description Copy and apply attributes of format tag that should be maintained. (style, class) Ignore \"__se__format__\" class\r\n   * @param {Element} originEl Origin element\r\n   * @param {Element} copyEl Element to copy\r\n   */\n  copyFormatAttributes: function copyFormatAttributes(originEl, copyEl) {\n    copyEl = copyEl.cloneNode(false);\n    copyEl.className = copyEl.className.replace(/(\\s|^)__se__format__[^\\s]+/g, '');\n    this.copyTagAttributes(originEl, copyEl);\n  },\n\n  /**\r\n   * @description Get the item from the array that matches the condition.\r\n   * @param {Array|HTMLCollection|NodeList} array Array to get item\r\n   * @param {Function|null} validation Conditional function\r\n   * @param {Boolean} multi If true, returns all items that meet the criteria otherwise, returns an empty array.\r\n   * If false, returns only one item that meet the criteria otherwise return null.\r\n   * @returns {Array|Node|null}\r\n   */\n  getArrayItem: function getArrayItem(array, validation, multi) {\n    if (!array || array.length === 0) return null;\n\n    validation = validation || function () {\n      return true;\n    };\n\n    var arr = [];\n\n    for (var i = 0, len = array.length, a; i < len; i++) {\n      a = array[i];\n\n      if (validation(a)) {\n        if (!multi) return a;else arr.push(a);\n      }\n    }\n\n    return !multi ? null : arr;\n  },\n\n  /**\r\n   * @description Check if an array contains an element \r\n   * @param {Array|HTMLCollection|NodeList} array element array\r\n   * @param {Node} element The element to check for\r\n   * @returns {Boolean}\r\n   */\n  arrayIncludes: function arrayIncludes(array, element) {\n    for (var i = 0; i < array.length; i++) {\n      if (array[i] === element) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /**\r\n   * @description Get the index of the argument value in the element array\r\n   * @param {Array|HTMLCollection|NodeList} array element array\r\n   * @param {Node} element The element to find index\r\n   * @returns {Number}\r\n   */\n  getArrayIndex: function getArrayIndex(array, element) {\n    var idx = -1;\n\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (array[i] === element) {\n        idx = i;\n        break;\n      }\n    }\n\n    return idx;\n  },\n\n  /**\r\n   * @description Get the next index of the argument value in the element array\r\n   * @param {Array|HTMLCollection|NodeList} array element array\r\n   * @param {Node} item The element to find index\r\n   * @returns {Number}\r\n   */\n  nextIdx: function nextIdx(array, item) {\n    var idx = this.getArrayIndex(array, item);\n    if (idx === -1) return -1;\n    return idx + 1;\n  },\n\n  /**\r\n   * @description Get the previous index of the argument value in the element array\r\n   * @param {Array|HTMLCollection|NodeList} array Element array\r\n   * @param {Node} item The element to find index\r\n   * @returns {Number}\r\n   */\n  prevIdx: function prevIdx(array, item) {\n    var idx = this.getArrayIndex(array, item);\n    if (idx === -1) return -1;\n    return idx - 1;\n  },\n\n  /**\r\n   * @description Returns the index compared to other sibling nodes.\r\n   * @param {Node} node The Node to find index\r\n   * @returns {Number}\r\n   */\n  getPositionIndex: function getPositionIndex(node) {\n    var idx = 0;\n\n    while (node = node.previousSibling) {\n      idx += 1;\n    }\n\n    return idx;\n  },\n\n  /**\r\n   * @description Returns the position of the \"node\" in the \"parentNode\" in a numerical array.\r\n   * ex) <p><span>aa</span><span>bb</span></p> : getNodePath(node: \"bb\", parentNode: \"<P>\") -> [1, 0]\r\n   * @param {Node} node The Node to find position path\r\n   * @param {Node|null} parentNode Parent node. If null, wysiwyg div area\r\n   * @param {Object|null} _newOffsets If you send an object of the form \"{s: 0, e: 0}\", the text nodes that are attached together are merged into one, centered on the \"node\" argument.\r\n   * \"_newOffsets.s\" stores the length of the combined characters after \"node\" and \"_newOffsets.e\" stores the length of the combined characters before \"node\".\r\n   * Do not use unless absolutely necessary.\r\n   * @returns {Array}\r\n   */\n  getNodePath: function getNodePath(node, parentNode, _newOffsets) {\n    var path = [];\n    var finds = true;\n    this.getParentElement(node, function (el) {\n      if (el === parentNode) finds = false;\n\n      if (finds && !this.isWysiwygDiv(el)) {\n        // merge text nodes\n        if (_newOffsets && el.nodeType === 3) {\n          var temp = null,\n              tempText = null;\n          _newOffsets.s = _newOffsets.e = 0;\n          var previous = el.previousSibling;\n\n          while (previous && previous.nodeType === 3) {\n            tempText = previous.textContent.replace(this.zeroWidthRegExp, '');\n            _newOffsets.s += tempText.length;\n            el.textContent = tempText + el.textContent;\n            temp = previous;\n            previous = previous.previousSibling;\n            this.removeItem(temp);\n          }\n\n          var next = el.nextSibling;\n\n          while (next && next.nodeType === 3) {\n            tempText = next.textContent.replace(this.zeroWidthRegExp, '');\n            _newOffsets.e += tempText.length;\n            el.textContent += tempText;\n            temp = next;\n            next = next.nextSibling;\n            this.removeItem(temp);\n          }\n        } // index push\n\n\n        path.push(el);\n      }\n\n      return false;\n    }.bind(this));\n    return path.map(this.getPositionIndex).reverse();\n  },\n\n  /**\r\n   * @description Returns the node in the location of the path array obtained from \"util.getNodePath\".\r\n   * @param {Array} offsets Position array, array obtained from \"util.getNodePath\"\r\n   * @param {Node} parentNode Base parent element\r\n   * @returns {Node}\r\n   */\n  getNodeFromPath: function getNodeFromPath(offsets, parentNode) {\n    var current = parentNode;\n    var nodes;\n\n    for (var i = 0, len = offsets.length; i < len; i++) {\n      nodes = current.childNodes;\n      if (nodes.length === 0) break;\n\n      if (nodes.length <= offsets[i]) {\n        current = nodes[nodes.length - 1];\n      } else {\n        current = nodes[offsets[i]];\n      }\n    }\n\n    return current;\n  },\n\n  /**\r\n   * @description Compares the style and class for equal values.\r\n   * Returns true if both are text nodes.\r\n   * @param {Node} a Node to compare\r\n   * @param {Node} b Node to compare\r\n   * @returns {Boolean}\r\n   */\n  isSameAttributes: function isSameAttributes(a, b) {\n    if (a.nodeType === 3 && b.nodeType === 3) return true;\n    if (a.nodeType === 3 || b.nodeType === 3) return false;\n    var style_a = a.style;\n    var style_b = b.style;\n    var compStyle = 0;\n\n    for (var i = 0, len = style_a.length; i < len; i++) {\n      if (style_a[style_a[i]] === style_b[style_a[i]]) compStyle++;\n    }\n\n    var class_a = a.classList;\n    var class_b = b.classList;\n    var reg = this._w.RegExp;\n    var compClass = 0;\n\n    for (var _i3 = 0, _len = class_a.length; _i3 < _len; _i3++) {\n      if (reg('(\\s|^)' + class_a[_i3] + '(\\s|$)').test(class_b.value)) compClass++;\n    }\n\n    return compStyle === style_b.length && compStyle === style_a.length && compClass === class_b.length && compClass === class_a.length;\n  },\n\n  /**\r\n   * @description Check the line element(util.isFormatElement) is empty.\r\n   * @param {Element} element Format element node\r\n   * @returns {Boolean}\r\n   */\n  isEmptyLine: function isEmptyLine(element) {\n    return !element || !element.parentNode || !element.querySelector('IMG, IFRAME, AUDIO, VIDEO, CANVAS, TABLE') && this.onlyZeroWidthSpace(element.textContent);\n  },\n\n  /**\r\n   * @description Check the span's attributes are empty.\r\n   * @param {Element|null} element Element node\r\n   * @returns {Boolean}\r\n   */\n  isSpanWithoutAttr: function isSpanWithoutAttr(element) {\n    return !!element && element.nodeType === 1 && /^SPAN$/i.test(element.nodeName) && !element.className && !element.style.cssText;\n  },\n\n  /**\r\n   * @description Check the node is a list (ol, ul)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isList: function isList(node) {\n    return node && /^(OL|UL)$/i.test(typeof node === 'string' ? node : node.nodeName);\n  },\n\n  /**\r\n   * @description Check the node is a list cell (li)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isListCell: function isListCell(node) {\n    return node && /^LI$/i.test(typeof node === 'string' ? node : node.nodeName);\n  },\n\n  /**\r\n   * @description Check the node is a table (table, thead, tbody, tr, th, td)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isTable: function isTable(node) {\n    return node && /^(TABLE|THEAD|TBODY|TR|TH|TD)$/i.test(typeof node === 'string' ? node : node.nodeName);\n  },\n\n  /**\r\n   * @description Check the node is a table cell (td, th)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isCell: function isCell(node) {\n    return node && /^(TD|TH)$/i.test(typeof node === 'string' ? node : node.nodeName);\n  },\n\n  /**\r\n   * @description Check the node is a break node (BR)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isBreak: function isBreak(node) {\n    return node && /^BR$/i.test(typeof node === 'string' ? node : node.nodeName);\n  },\n\n  /**\r\n   * @description Check the node is a anchor node (A)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isAnchor: function isAnchor(node) {\n    return node && /^A$/i.test(typeof node === 'string' ? node : node.nodeName);\n  },\n\n  /**\r\n   * @description Check the node is a media node (img, iframe, audio, video, canvas)\r\n   * @param {Node|String} node The element or element name to check\r\n   * @returns {Boolean}\r\n   */\n  isMedia: function isMedia(node) {\n    return node && /^(IMG|IFRAME|AUDIO|VIDEO|CANVAS)$/i.test(typeof node === 'string' ? node : node.nodeName);\n  },\n\n  /**\r\n   * @description Checks for numeric (with decimal point).\r\n   * @param {String|Number} text Text string or number\r\n   * @returns {Boolean}\r\n   */\n  isNumber: function isNumber(text) {\n    return !!text && /^-?\\d+(\\.\\d+)?$/.test(text + '');\n  },\n\n  /**\r\n   * @description Get a number.\r\n   * @param {String|Number} text Text string or number\r\n   * @param {Number} maxDec Maximum number of decimal places (-1 : Infinity)\r\n   * @returns {Number}\r\n   */\n  getNumber: function getNumber(text, maxDec) {\n    if (!text) return 0;\n    var number = (text + '').match(/-?\\d+(\\.\\d+)?/);\n    if (!number || !number[0]) return 0;\n    number = number[0];\n    return maxDec < 0 ? number * 1 : maxDec === 0 ? this._w.Math.round(number * 1) : (number * 1).toFixed(maxDec) * 1;\n  },\n\n  /**\r\n   * @description Get all \"children\" of the argument value element (Without text nodes)\r\n   * @param {Element} element element to get child node\r\n   * @param {Function|null} validation Conditional function\r\n   * @returns {Array}\r\n   */\n  getListChildren: function getListChildren(element, validation) {\n    var children = [];\n    if (!element || !element.children || element.children.length === 0) return children;\n\n    validation = validation || function () {\n      return true;\n    };\n\n    (function recursionFunc(current) {\n      if (element !== current && validation(current)) {\n        children.push(current);\n      }\n\n      if (!!current.children) {\n        for (var i = 0, len = current.children.length; i < len; i++) {\n          recursionFunc(current.children[i]);\n        }\n      }\n    })(element);\n\n    return children;\n  },\n\n  /**\r\n   * @description Get all \"childNodes\" of the argument value element (Include text nodes)\r\n   * @param {Node} element element to get child node\r\n   * @param {Function|null} validation Conditional function\r\n   * @returns {Array}\r\n   */\n  getListChildNodes: function getListChildNodes(element, validation) {\n    var children = [];\n    if (!element || element.childNodes.length === 0) return children;\n\n    validation = validation || function () {\n      return true;\n    };\n\n    (function recursionFunc(current) {\n      if (element !== current && validation(current)) {\n        children.push(current);\n      }\n\n      for (var i = 0, len = current.childNodes.length; i < len; i++) {\n        recursionFunc(current.childNodes[i]);\n      }\n    })(element);\n\n    return children;\n  },\n\n  /**\r\n   * @description Returns the number of parents nodes.\r\n   * \"0\" when the parent node is the WYSIWYG area.\r\n   * \"-1\" when the element argument is the WYSIWYG area.\r\n   * @param {Node} element The element to check\r\n   * @returns {Number}\r\n   */\n  getElementDepth: function getElementDepth(element) {\n    if (!element || this.isWysiwygDiv(element)) return -1;\n    var depth = 0;\n    element = element.parentNode;\n\n    while (element && !this.isWysiwygDiv(element)) {\n      depth += 1;\n      element = element.parentNode;\n    }\n\n    return depth;\n  },\n\n  /**\r\n   * @description Compares two elements to find a common ancestor, and returns the order of the two elements.\r\n   * @param {Node} a Node to compare.\r\n   * @param {Node} b Node to compare.\r\n   * @returns {Object} { ancesstor, a, b, result: (a > b ? 1 : a < b ? -1 : 0) };\r\n   */\n  compareElements: function compareElements(a, b) {\n    var aNode = a,\n        bNode = b;\n\n    while (aNode && bNode && aNode.parentNode !== bNode.parentNode) {\n      aNode = aNode.parentNode;\n      bNode = bNode.parentNode;\n    }\n\n    if (!aNode || !bNode) return {\n      ancestor: null,\n      a: a,\n      b: b,\n      result: 0\n    };\n    var children = aNode.parentNode.childNodes;\n    var aIndex = this.getArrayIndex(children, aNode);\n    var bIndex = this.getArrayIndex(children, bNode);\n    return {\n      ancestor: aNode.parentNode,\n      a: aNode,\n      b: bNode,\n      result: aIndex > bIndex ? 1 : aIndex < bIndex ? -1 : 0\n    };\n  },\n\n  /**\r\n   * @description Get the parent element of the argument value.\r\n   * A tag that satisfies the query condition is imported.\r\n   * Returns null if not found.\r\n   * @param {Node} element Reference element\r\n   * @param {String|Function} query Query String (nodeName, .className, #ID, :name) or validation function.\r\n   * Not use it like jquery.\r\n   * Only one condition can be entered at a time.\r\n   * @returns {Element|null}\r\n   */\n  getParentElement: function getParentElement(element, query) {\n    var check;\n\n    if (typeof query === 'function') {\n      check = query;\n    } else {\n      var attr;\n\n      if (/^\\./.test(query)) {\n        attr = 'className';\n        query = query.split('.')[1];\n      } else if (/^#/.test(query)) {\n        attr = 'id';\n        query = '^' + query.split('#')[1] + '$';\n      } else if (/^:/.test(query)) {\n        attr = 'name';\n        query = '^' + query.split(':')[1] + '$';\n      } else {\n        attr = 'nodeName';\n        query = '^' + query + '$';\n      }\n\n      var regExp = new this._w.RegExp(query, 'i');\n\n      check = function check(el) {\n        return regExp.test(el[attr]);\n      };\n    }\n\n    while (element && !check(element)) {\n      if (this.isWysiwygDiv(element)) {\n        return null;\n      }\n\n      element = element.parentNode;\n    }\n\n    return element;\n  },\n\n  /**\r\n   * @description Get the child element of the argument value.\r\n   * A tag that satisfies the query condition is imported.\r\n   * Returns null if not found.\r\n   * @param {Node} element Reference element\r\n   * @param {String|Function} query Query String (nodeName, .className, #ID, :name) or validation function.\r\n   * @param {Boolean} last If true returns the last node among the found child nodes. (default: first node)\r\n   * Not use it like jquery.\r\n   * Only one condition can be entered at a time.\r\n   * @returns {Element|null}\r\n   */\n  getChildElement: function getChildElement(element, query, last) {\n    var check;\n\n    if (typeof query === 'function') {\n      check = query;\n    } else {\n      var attr;\n\n      if (/^\\./.test(query)) {\n        attr = 'className';\n        query = query.split('.')[1];\n      } else if (/^#/.test(query)) {\n        attr = 'id';\n        query = '^' + query.split('#')[1] + '$';\n      } else if (/^:/.test(query)) {\n        attr = 'name';\n        query = '^' + query.split(':')[1] + '$';\n      } else {\n        attr = 'nodeName';\n        query = '^' + (query === 'text' ? '#' + query : query) + '$';\n      }\n\n      var regExp = new this._w.RegExp(query, 'i');\n\n      check = function check(el) {\n        return regExp.test(el[attr]);\n      };\n    }\n\n    var childList = this.getListChildNodes(element, function (current) {\n      return check(current);\n    });\n    return childList[last ? childList.length - 1 : 0];\n  },\n\n  /**\r\n   * @description 1. The first node of all the child nodes of the \"first\" element is returned.\r\n   * 2. The last node of all the child nodes of the \"last\" element is returned.\r\n   * 3. When there is no \"last\" element, the first and last nodes of all the children of the \"first\" element are returned.\r\n   * { sc: \"first\", ec: \"last\" }\r\n   * @param {Node} first First element\r\n   * @param {Node|null} last Last element\r\n   * @returns {Object}\r\n   */\n  getEdgeChildNodes: function getEdgeChildNodes(first, last) {\n    if (!first) return;\n    if (!last) last = first;\n\n    while (first && first.nodeType === 1 && first.childNodes.length > 0 && !this.isBreak(first)) {\n      first = first.firstChild;\n    }\n\n    while (last && last.nodeType === 1 && last.childNodes.length > 0 && !this.isBreak(last)) {\n      last = last.lastChild;\n    }\n\n    return {\n      sc: first,\n      ec: last || first\n    };\n  },\n\n  /**\r\n   * @description Returns the position of the left and top of argument. {left:0, top:0}\r\n   * @param {Node} element Target node\r\n   * @param {Element|null} wysiwygFrame When use iframe option, iframe object should be sent (context.element.wysiwygFrame)\r\n   * @returns {Object}\r\n   */\n  getOffset: function getOffset(element, wysiwygFrame) {\n    var offsetLeft = 0;\n    var offsetTop = 0;\n    var offsetElement = element.nodeType === 3 ? element.parentElement : element;\n    var wysiwyg = this.getParentElement(element, this.isWysiwygDiv.bind(this));\n\n    while (offsetElement && !this.hasClass(offsetElement, 'se-container') && offsetElement !== wysiwyg) {\n      offsetLeft += offsetElement.offsetLeft;\n      offsetTop += offsetElement.offsetTop;\n      offsetElement = offsetElement.offsetParent;\n    }\n\n    var iframe = wysiwygFrame && /iframe/i.test(wysiwygFrame.nodeName);\n    return {\n      left: offsetLeft + (iframe ? wysiwygFrame.parentElement.offsetLeft : 0),\n      top: offsetTop - (wysiwyg ? wysiwyg.scrollTop : 0) + (iframe ? wysiwygFrame.parentElement.offsetTop : 0)\n    };\n  },\n\n  /**\r\n   * @description It compares the start and end indexes of \"a\" and \"b\" and returns the number of overlapping indexes in the range.\r\n   * ex) 1, 5, 4, 6 => \"2\" (4 ~ 5)\r\n   * @param {Number} aStart Start index of \"a\"\r\n   * @param {Number} aEnd End index of \"a\"\r\n   * @param {Number} bStart Start index of \"b\"\r\n   * @param {Number} bEnd Start index of \"b\"\r\n   * @returns {Number}\r\n   */\n  getOverlapRangeAtIndex: function getOverlapRangeAtIndex(aStart, aEnd, bStart, bEnd) {\n    if (aStart <= bEnd ? aEnd < bStart : aEnd > bStart) return 0;\n    var overlap = (aStart > bStart ? aStart : bStart) - (aEnd < bEnd ? aEnd : bEnd);\n    return (overlap < 0 ? overlap * -1 : overlap) + 1;\n  },\n\n  /**\r\n   * @description Set the text content value of the argument value element\r\n   * @param {Node} element Element to replace text content\r\n   * @param {String} txt Text to be applied\r\n   */\n  changeTxt: function changeTxt(element, txt) {\n    if (!element || !txt) return;\n    element.textContent = txt;\n  },\n\n  /**\r\n   * @description Replace element\r\n   * @param {Element} element Target element\r\n   * @param {String|Element} newElement String or element of the new element to apply\r\n   */\n  changeElement: function changeElement(element, newElement) {\n    if (typeof newElement === 'string') {\n      if (element.outerHTML) {\n        element.outerHTML = newElement;\n      } else {\n        var doc = this.createElement('DIV');\n        doc.innerHTML = newElement;\n        newElement = doc.firstChild;\n        element.parentNode.replaceChild(newElement, element);\n      }\n    } else if (newElement.nodeType === 1) {\n      element.parentNode.replaceChild(newElement, element);\n    }\n  },\n\n  /**\r\n   * @description Set style, if all styles are deleted, the style properties are deleted.\r\n   * @param {Element} element Element to set style\r\n   * @param {String} styleName Style attribute name (marginLeft, textAlign...)\r\n   * @param {String|Number} value Style value\r\n   */\n  setStyle: function setStyle(element, styleName, value) {\n    element.style[styleName] = value;\n\n    if (!value && !element.style.cssText) {\n      element.removeAttribute('style');\n    }\n  },\n\n  /**\r\n   * @description Determine whether any of the matched elements are assigned the given class\r\n   * @param {Element} element Elements to search class name\r\n   * @param {String} className Class name to search for\r\n   * @returns {Boolean}\r\n   */\n  hasClass: function hasClass(element, className) {\n    if (!element) return;\n    return new this._w.RegExp(className).test(element.className);\n  },\n\n  /**\r\n   * @description Append the className value of the argument value element\r\n   * @param {Element} element Elements to add class name\r\n   * @param {String} className Class name to be add\r\n   */\n  addClass: function addClass(element, className) {\n    if (!element) return;\n    var check = new this._w.RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\n    if (check.test(element.className)) return;\n    element.className += (element.className.length > 0 ? ' ' : '') + className;\n  },\n\n  /**\r\n   * @description Delete the className value of the argument value element\r\n   * @param {Element} element Elements to remove class name\r\n   * @param {String} className Class name to be remove\r\n   */\n  removeClass: function removeClass(element, className) {\n    if (!element) return;\n    var check = new this._w.RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\n    element.className = element.className.replace(check, ' ').trim();\n    if (!element.className.trim()) element.removeAttribute('class');\n  },\n\n  /**\r\n   * @description Argument value If there is no class name, insert it and delete the class name if it exists\r\n   * @param {Element} element Elements to replace class name\r\n   * @param {String} className Class name to be change\r\n   * @returns {Boolean|undefined}\r\n   */\n  toggleClass: function toggleClass(element, className) {\n    if (!element) return;\n    var result = false;\n    var check = new this._w.RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\n\n    if (check.test(element.className)) {\n      element.className = element.className.replace(check, ' ').trim();\n    } else {\n      element.className += ' ' + className;\n      result = true;\n    }\n\n    if (!element.className.trim()) element.removeAttribute('class');\n    return result;\n  },\n\n  /**\r\n   * @description Checks if element can't be easily enabled\r\n   * @param {Element} element Element to check for\r\n   */\n  isImportantDisabled: function isImportantDisabled(element) {\n    return element.hasAttribute('data-important-disabled');\n  },\n\n  /**\r\n   * @description In the predefined code view mode, the buttons except the executable button are changed to the 'disabled' state.\r\n   * core.codeViewDisabledButtons (An array of buttons whose class name is not \"se-code-view-enabled\")\r\n   * core.resizingDisabledButtons (An array of buttons whose class name is not \"se-resizing-enabled\")\r\n   * @param {Boolean} disabled Disabled value\r\n   * @param {Array|HTMLCollection|NodeList} buttonList Button array\r\n   * @param {Boolean} important If priveleged mode should be used (Necessary to switch importantDisabled buttons)\r\n   */\n  setDisabledButtons: function setDisabledButtons(disabled, buttonList, important) {\n    for (var i = 0, len = buttonList.length; i < len; i++) {\n      var button = buttonList[i];\n      if (important || !this.isImportantDisabled(button)) button.disabled = disabled;\n\n      if (important) {\n        if (disabled) {\n          button.setAttribute('data-important-disabled', '');\n        } else {\n          button.removeAttribute('data-important-disabled');\n        }\n      }\n    }\n  },\n\n  /**\r\n   * @description Delete argumenu value element\r\n   * @param {Node} item Node to be remove\r\n   */\n  removeItem: function removeItem(item) {\n    if (!item) return;\n    if (typeof item.remove === 'function') item.remove();else if (item.parentNode) item.parentNode.removeChild(item);\n  },\n\n  /**\r\n   * @description Delete all parent nodes that match the condition.\r\n   * Returns an {sc: previousSibling, ec: nextSibling}(the deleted node reference) or null.\r\n   * @param {Node} item Node to be remove\r\n   * @param {Function|null} validation Validation function. default(Deleted if it only have breakLine and blanks)\r\n   * @param {Element|null} stopParent Stop when the parent node reaches stopParent\r\n   * @returns {Object|null} {sc: previousSibling, ec: nextSibling}\r\n   */\n  removeItemAllParents: function removeItemAllParents(item, validation, stopParent) {\n    if (!item) return null;\n    var cc = null;\n\n    if (!validation) {\n      validation = function (current) {\n        if (current === stopParent || this.isComponent(current)) return false;\n        var text = current.textContent.trim();\n        return text.length === 0 || /^(\\n|\\u200B)+$/.test(text);\n      }.bind(this);\n    }\n\n    (function recursionFunc(element) {\n      if (!util.isWysiwygDiv(element)) {\n        var parent = element.parentNode;\n\n        if (parent && validation(element)) {\n          cc = {\n            sc: element.previousElementSibling,\n            ec: element.nextElementSibling\n          };\n          util.removeItem(element);\n          recursionFunc(parent);\n        }\n      }\n    })(item);\n\n    return cc;\n  },\n\n  /**\r\n   * @description Detach Nested all nested lists under the \"baseNode\".\r\n   * Returns a list with nested removed.\r\n   * @param {Node} baseNode Element on which to base.\r\n   * @param {Boolean} all If true, it also detach all nested lists of a returned list.\r\n   * @returns {Element}\r\n   */\n  detachNestedList: function detachNestedList(baseNode, all) {\n    var rNode = this._deleteNestedList(baseNode);\n\n    var rangeElement, cNodes;\n\n    if (rNode) {\n      rangeElement = rNode.cloneNode(false);\n      cNodes = rNode.childNodes;\n      var index = this.getPositionIndex(baseNode);\n\n      while (cNodes[index]) {\n        rangeElement.appendChild(cNodes[index]);\n      }\n    } else {\n      rangeElement = baseNode;\n    }\n\n    var rChildren;\n\n    if (!all) {\n      var depth = this.getElementDepth(baseNode) + 2;\n      rChildren = this.getListChildren(baseNode, function (current) {\n        return this.isListCell(current) && !current.previousElementSibling && this.getElementDepth(current) === depth;\n      }.bind(this));\n    } else {\n      rChildren = this.getListChildren(rangeElement, function (current) {\n        return this.isListCell(current) && !current.previousElementSibling;\n      }.bind(this));\n    }\n\n    for (var i = 0, len = rChildren.length; i < len; i++) {\n      this._deleteNestedList(rChildren[i]);\n    }\n\n    if (rNode) {\n      rNode.parentNode.insertBefore(rangeElement, rNode.nextSibling);\n      if (cNodes && cNodes.length === 0) this.removeItem(rNode);\n    }\n\n    return rangeElement === baseNode ? rangeElement.parentNode : rangeElement;\n  },\n\n  /**\r\n   * @description Sub function of util.detachNestedList method.\r\n   * @private\r\n   */\n  _deleteNestedList: function _deleteNestedList(baseNode) {\n    var baseParent = baseNode.parentNode;\n    var sibling = baseParent;\n    var parent = sibling.parentNode;\n    var liSibling, liParent, child, index, c;\n\n    while (this.isListCell(parent)) {\n      index = this.getPositionIndex(baseNode);\n      liSibling = parent.nextElementSibling;\n      liParent = parent.parentNode;\n      child = sibling;\n\n      while (child) {\n        sibling = sibling.nextSibling;\n\n        if (this.isList(child)) {\n          c = child.childNodes;\n\n          while (c[index]) {\n            liParent.insertBefore(c[index], liSibling);\n          }\n\n          if (c.length === 0) this.removeItem(child);\n        } else {\n          liParent.appendChild(child);\n        }\n\n        child = sibling;\n      }\n\n      sibling = liParent;\n      parent = liParent.parentNode;\n    }\n\n    if (baseParent.children.length === 0) this.removeItem(baseParent);\n    return liParent;\n  },\n\n  /**\r\n   * @description Split all tags based on \"baseNode\"\r\n   * Returns the last element of the splited tag.\r\n   * @param {Node} baseNode Element or text node on which to base\r\n   * @param {Number|Node|null} offset Text offset of \"baseNode\" (Only valid when \"baseNode\" is a text node)\r\n   * @param {Number} depth The nesting depth of the element being split. (default: 0)\r\n   * @returns {Element}\r\n   */\n  splitElement: function splitElement(baseNode, offset, depth) {\n    if (this.isWysiwygDiv(baseNode)) return baseNode;\n\n    if (!!offset && !this.isNumber(offset)) {\n      var _children = baseNode.childNodes;\n\n      var _index = this.getPositionIndex(offset);\n\n      var prev = baseNode.cloneNode(false);\n\n      var _next = baseNode.cloneNode(false);\n\n      for (var i = 0, len = _children.length; i < len; i++) {\n        if (i < _index) prev.appendChild(_children[i]);else if (i > _index) _next.appendChild(_children[i]);else continue;\n        i--;\n        len--;\n        _index--;\n      }\n\n      if (prev.childNodes.length > 0) baseNode.parentNode.insertBefore(prev, baseNode);\n      if (_next.childNodes.length > 0) baseNode.parentNode.insertBefore(_next, baseNode.nextElementSibling);\n      return baseNode;\n    }\n\n    var bp = baseNode.parentNode;\n    var index = 0,\n        newEl,\n        children,\n        temp;\n    var next = true;\n    if (!depth || depth < 0) depth = 0;\n\n    if (baseNode.nodeType === 3) {\n      index = this.getPositionIndex(baseNode);\n\n      if (offset >= 0) {\n        baseNode.splitText(offset);\n        var after = this.getNodeFromPath([index + 1], bp);\n        if (this.onlyZeroWidthSpace(after)) after.data = this.zeroWidthSpace;\n      }\n    } else if (baseNode.nodeType === 1) {\n      if (!baseNode.previousSibling) {\n        if (this.getElementDepth(baseNode) === depth) next = false;\n      } else {\n        baseNode = baseNode.previousSibling;\n      }\n    }\n\n    var depthEl = baseNode;\n\n    while (this.getElementDepth(depthEl) > depth) {\n      index = this.getPositionIndex(depthEl) + 1;\n      depthEl = depthEl.parentNode;\n      temp = newEl;\n      newEl = depthEl.cloneNode(false);\n      children = depthEl.childNodes;\n\n      if (temp) {\n        if (this.isListCell(newEl) && this.isList(temp) && temp.firstElementChild) {\n          newEl.innerHTML = temp.firstElementChild.innerHTML;\n          util.removeItem(temp.firstElementChild);\n          if (temp.children.length > 0) newEl.appendChild(temp);\n        } else {\n          newEl.appendChild(temp);\n        }\n      }\n\n      while (children[index]) {\n        newEl.appendChild(children[index]);\n      }\n    }\n\n    if (depthEl.childNodes.length <= 1 && (!depthEl.firstChild || depthEl.firstChild.textContent.length === 0)) depthEl.innerHTML = '<br>';\n    var pElement = depthEl.parentNode;\n    if (next) depthEl = depthEl.nextSibling;\n    if (!newEl) return depthEl;\n    this.mergeSameTags(newEl, null, false);\n    this.mergeNestedTags(newEl, function (current) {\n      return this.isList(current);\n    }.bind(this));\n    if (newEl.childNodes.length > 0) pElement.insertBefore(newEl, depthEl);else newEl = depthEl;\n    if (bp.childNodes.length === 0) this.removeItem(bp);\n    return newEl;\n  },\n\n  /**\r\n   * @description Use with \"npdePath (util.getNodePath)\" to merge the same attributes and tags if they are present and modify the nodepath.\r\n   * If \"offset\" has been changed, it will return as much \"offset\" as it has been modified.\r\n   * An array containing change offsets is returned in the order of the \"nodePathArray\" array.\r\n   * @param {Element} element Element\r\n   * @param {Array|null} nodePathArray Array of NodePath object ([util.getNodePath(), ..])\r\n   * @param {Boolean} onlyText If true, non-text nodes(!util._isIgnoreNodeChange) like 'span', 'strong'.. are ignored.\r\n   * @returns {Array} [offset, ..]\r\n   */\n  mergeSameTags: function mergeSameTags(element, nodePathArray, onlyText) {\n    var inst = this;\n    var nodePathLen = nodePathArray ? nodePathArray.length : 0;\n    var offsets = null;\n\n    if (nodePathLen) {\n      offsets = this._w.Array.apply(null, new this._w.Array(nodePathLen)).map(this._w.Number.prototype.valueOf, 0);\n    }\n\n    (function recursionFunc(current, depth, depthIndex) {\n      var children = current.childNodes;\n\n      for (var i = 0, len = children.length, child, next; i < len; i++) {\n        child = children[i];\n        next = children[i + 1];\n        if (!child) break;\n\n        if (onlyText && inst._isIgnoreNodeChange(child) || !onlyText && (inst.isTable(child) || inst.isListCell(child) || inst.isFormatElement(child) && !inst.isFreeFormatElement(child))) {\n          if (inst.isTable(child) || inst.isListCell(child)) {\n            recursionFunc(child, depth + 1, i);\n          }\n\n          continue;\n        }\n\n        if (len === 1 && current.nodeName === child.nodeName && current.parentNode) {\n          // update nodePath\n          if (nodePathLen) {\n            var path = void 0,\n                c = void 0,\n                p = void 0,\n                cDepth = void 0,\n                spliceDepth = void 0;\n\n            for (var n = 0; n < nodePathLen; n++) {\n              path = nodePathArray[n];\n\n              if (path && path[depth] === i) {\n                c = child, p = current, cDepth = depth, spliceDepth = true;\n\n                while (cDepth >= 0) {\n                  if (inst.getArrayIndex(p.childNodes, c) !== path[cDepth]) {\n                    spliceDepth = false;\n                    break;\n                  }\n\n                  c = child.parentNode;\n                  p = c.parentNode;\n                  cDepth--;\n                }\n\n                if (spliceDepth) {\n                  path.splice(depth, 1);\n                  path[depth] = i;\n                }\n              }\n            }\n          } // merge tag\n\n\n          inst.copyTagAttributes(child, current);\n          current.parentNode.insertBefore(child, current);\n          inst.removeItem(current);\n        }\n\n        if (!next) {\n          if (child.nodeType === 1) recursionFunc(child, depth + 1, i);\n          break;\n        }\n\n        if (child.nodeName === next.nodeName && inst.isSameAttributes(child, next) && child.href === next.href) {\n          var childs = child.childNodes;\n          var childLength = 0;\n\n          for (var _n = 0, nLen = childs.length; _n < nLen; _n++) {\n            if (childs[_n].textContent.length > 0) childLength++;\n          }\n\n          var l = child.lastChild;\n          var r = next.firstChild;\n          var addOffset = 0;\n\n          if (l && r) {\n            var textOffset = l.nodeType === 3 && r.nodeType === 3;\n            addOffset = l.textContent.length;\n            var tempL = l.previousSibling;\n\n            while (tempL && tempL.nodeType === 3) {\n              addOffset += tempL.textContent.length;\n              tempL = tempL.previousSibling;\n            }\n\n            if (childLength > 0 && l.nodeType === 3 && r.nodeType === 3 && (l.textContent.length > 0 || r.textContent.length > 0)) childLength--;\n\n            if (nodePathLen) {\n              var _path = null;\n\n              for (var _n2 = 0; _n2 < nodePathLen; _n2++) {\n                _path = nodePathArray[_n2];\n\n                if (_path && _path[depth] > i) {\n                  if (depth > 0 && _path[depth - 1] !== depthIndex) continue;\n                  _path[depth] -= 1;\n\n                  if (_path[depth + 1] >= 0 && _path[depth] === i) {\n                    _path[depth + 1] += childLength;\n\n                    if (textOffset) {\n                      if (l && l.nodeType === 3 && r && r.nodeType === 3) {\n                        offsets[_n2] += addOffset;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          if (child.nodeType === 3) {\n            addOffset = child.textContent.length;\n            child.textContent += next.textContent;\n\n            if (nodePathLen) {\n              var _path2 = null;\n\n              for (var _n3 = 0; _n3 < nodePathLen; _n3++) {\n                _path2 = nodePathArray[_n3];\n\n                if (_path2 && _path2[depth] > i) {\n                  if (depth > 0 && _path2[depth - 1] !== depthIndex) continue;\n                  _path2[depth] -= 1;\n\n                  if (_path2[depth + 1] >= 0 && _path2[depth] === i) {\n                    _path2[depth + 1] += childLength;\n                    offsets[_n3] += addOffset;\n                  }\n                }\n              }\n            }\n          } else {\n            child.innerHTML += next.innerHTML;\n          }\n\n          inst.removeItem(next);\n          i--;\n        } else if (child.nodeType === 1) {\n          recursionFunc(child, depth + 1, i);\n        }\n      }\n    })(element, 0, 0);\n\n    return offsets;\n  },\n\n  /**\r\n   * @description Remove nested tags without other child nodes.\r\n   * @param {Element} element Element object\r\n   * @param {Function|String|null} validation Validation function / String(\"tag1|tag2..\") / If null, all tags are applicable.\r\n   */\n  mergeNestedTags: function mergeNestedTags(element, validation) {\n    if (typeof validation === 'string') {\n      validation = function (current) {\n        return this.test(current.tagName);\n      }.bind(new this._w.RegExp('^(' + (validation ? validation : '.+') + ')$', 'i'));\n    } else if (typeof validation !== 'function') {\n      validation = function validation() {\n        return true;\n      };\n    }\n\n    (function recursionFunc(current) {\n      var children = current.children;\n\n      if (children.length === 1 && children[0].nodeName === current.nodeName && validation(current)) {\n        var temp = children[0];\n        children = temp.children;\n\n        while (children[0]) {\n          current.appendChild(children[0]);\n        }\n\n        current.removeChild(temp);\n      }\n\n      for (var i = 0, len = current.children.length; i < len; i++) {\n        recursionFunc(current.children[i]);\n      }\n    })(element);\n  },\n\n  /**\r\n   * @description Delete a empty child node of argument element\r\n   * @param {Element} element Element node\r\n   * @param {Node|null} notRemoveNode Do not remove node\r\n   */\n  removeEmptyNode: function removeEmptyNode(element, notRemoveNode) {\n    var inst = this;\n\n    if (notRemoveNode) {\n      notRemoveNode = inst.getParentElement(notRemoveNode, function (current) {\n        return element === current.parentElement;\n      });\n    }\n\n    (function recursionFunc(current) {\n      if (inst._notTextNode(current) || current === notRemoveNode || inst.isNonEditable(current)) return 0;\n\n      if (current !== element && inst.onlyZeroWidthSpace(current.textContent) && (!current.firstChild || !inst.isBreak(current.firstChild)) && !current.querySelector(inst._allowedEmptyNodeList)) {\n        if (current.parentNode) {\n          current.parentNode.removeChild(current);\n          return -1;\n        }\n      } else {\n        var children = current.children;\n\n        for (var i = 0, len = children.length, r = 0; i < len; i++) {\n          if (!children[i + r] || inst.isComponent(children[i + r])) continue;\n          r += recursionFunc(children[i + r]);\n        }\n      }\n\n      return 0;\n    })(element);\n\n    if (element.childNodes.length === 0) element.innerHTML = '<br>';\n  },\n\n  /**\r\n   * @description Remove whitespace between tags in HTML string.\r\n   * @param {String} html HTML string\r\n   * @returns {String}\r\n   */\n  htmlRemoveWhiteSpace: function htmlRemoveWhiteSpace(html) {\n    if (!html) return '';\n    return html.trim().replace(/<\\/?(?!strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code|summary)[^>^<]+>\\s+(?=<)/ig, function (m) {\n      return m.replace(/\\n/g, '').replace(/\\s+/, ' ');\n    });\n  },\n\n  /**\r\n   * @description Sort a element array by depth of element.\r\n   * @param {Array} array Array object\r\n   * @param {Boolean} des true: descending order / false: ascending order\r\n   */\n  sortByDepth: function sortByDepth(array, des) {\n    var t = !des ? -1 : 1;\n    var f = t * -1;\n    array.sort(function (a, b) {\n      if (!this.isListCell(a) || !this.isListCell(b)) return 0;\n      a = this.getElementDepth(a);\n      b = this.getElementDepth(b);\n      return a > b ? t : a < b ? f : 0;\n    }.bind(this));\n  },\n\n  /**\r\n   * @description Nodes that need to be added without modification when changing text nodes\r\n   * @param {Node} element Element to check\r\n   * @returns {Boolean}\r\n   * @private\r\n   */\n  _isIgnoreNodeChange: function _isIgnoreNodeChange(element) {\n    return element && element.nodeType !== 3 && (this.isNonEditable(element) || !this.isTextStyleElement(element));\n  },\n\n  /**\r\n   * @description Nodes that must remain undetached when changing text nodes (A, Label, Code, Span:font-size)\r\n   * @param {Node|String} element Element to check\r\n   * @returns {Boolean}\r\n   * @private\r\n   */\n  _isMaintainedNode: function _isMaintainedNode(element) {\n    return element && element.nodeType !== 3 && /^(a|label|code|summary)$/i.test(typeof element === 'string' ? element : element.nodeName);\n  },\n\n  /**\r\n   * @description Node with font-size style\r\n   * @param {Node} element Element to check\r\n   * @returns {Boolean}\r\n   * @private\r\n   */\n  _isSizeNode: function _isSizeNode(element) {\n    return element && element.nodeType !== 3 && this.isTextStyleElement(element) && !!element.style.fontSize;\n  },\n\n  /**\r\n   * @description Nodes without text\r\n   * @param {Node} element Element to check\r\n   * @returns {Boolean}\r\n   * @private\r\n   */\n  _notTextNode: function _notTextNode(element) {\n    return element && element.nodeType !== 3 && (this.isComponent(element) || /^(br|input|select|canvas|img|iframe|audio|video)$/i.test(typeof element === 'string' ? element : element.nodeName));\n  },\n\n  /**\r\n   * @description Check disallowed tags\r\n   * @param {Node} element Element to check\r\n   * @returns {Boolean}\r\n   * @private\r\n   */\n  _disallowedTags: function _disallowedTags(element) {\n    return /^(meta|script|link|style|[a-z]+\\:[a-z]+)$/i.test(element.nodeName);\n  },\n\n  /**\r\n   * @description Create whitelist RegExp object.\r\n   * Return RegExp format: new RegExp(\"<\\\\/?\\\\b(?!\" + list + \")\\\\b[^>^<]*+>\", \"gi\")\r\n   * @param {String} list Tags list (\"br|p|div|pre...\")\r\n   * @returns {RegExp}\r\n   */\n  createTagsWhitelist: function createTagsWhitelist(list) {\n    return new RegExp('<\\\\/?\\\\b(?!\\\\b' + (list || '').replace(/\\|/g, '\\\\b|\\\\b') + '\\\\b)[^>]*>', 'gi');\n  },\n\n  /**\r\n   * @description Create blacklist RegExp object.\r\n   * Return RegExp format: new RegExp(\"<\\\\/?\\\\b(?:\" + list + \")\\\\b[^>^<]*+>\", \"gi\")\r\n   * @param {String} list Tags list (\"br|p|div|pre...\")\r\n   * @returns {RegExp}\r\n   */\n  createTagsBlacklist: function createTagsBlacklist(list) {\n    return new RegExp('<\\\\/?\\\\b(?:\\\\b' + (list || '^').replace(/\\|/g, '\\\\b|\\\\b') + '\\\\b)[^>]*>', 'gi');\n  },\n\n  /**\r\n   * @description Fix tags that do not fit the editor format.\r\n   * @param {Element} documentFragment Document fragment \"DOCUMENT_FRAGMENT_NODE\" (nodeType === 11)\r\n   * @param {RegExp} htmlCheckWhitelistRegExp Editor tags whitelist (core._htmlCheckWhitelistRegExp)\r\n   * @param {RegExp} htmlCheckBlacklistRegExp Editor tags blacklist (core._htmlCheckBlacklistRegExp)\r\n   * @param {Boolean} lowLevelCheck Row level check\r\n   * @private\r\n   */\n  _consistencyCheckOfHTML: function _consistencyCheckOfHTML(documentFragment, htmlCheckWhitelistRegExp, htmlCheckBlacklistRegExp, lowLevelCheck) {\n    /**\r\n     * It is can use \".children(util.getListChildren)\" to exclude text nodes, but \"documentFragment.children\" is not supported in IE.\r\n     * So check the node type and exclude the text no (current.nodeType !== 1)\r\n     */\n    var removeTags = [],\n        emptyTags = [],\n        wrongList = [],\n        withoutFormatCells = []; // wrong position\n\n    var wrongTags = this.getListChildNodes(documentFragment, function (current) {\n      if (current.nodeType !== 1) {\n        if (this.isList(current.parentNode)) removeTags.push(current);\n        return false;\n      } // white list\n\n\n      if (htmlCheckBlacklistRegExp.test(current.nodeName) || !htmlCheckWhitelistRegExp.test(current.nodeName) && current.childNodes.length === 0 && this.isNotCheckingNode(current)) {\n        removeTags.push(current);\n        return false;\n      }\n\n      var nrtag = !this.getParentElement(current, this.isNotCheckingNode); // empty tags\n\n      if (!this.isTable(current) && !this.isListCell(current) && !this.isAnchor(current) && (this.isFormatElement(current) || this.isRangeFormatElement(current) || this.isTextStyleElement(current)) && current.childNodes.length === 0 && nrtag) {\n        emptyTags.push(current);\n        return false;\n      } // wrong list\n\n\n      if (this.isList(current.parentNode) && !this.isList(current) && !this.isListCell(current)) {\n        wrongList.push(current);\n        return false;\n      } // table cells\n\n\n      if (this.isCell(current)) {\n        var fel = current.firstElementChild;\n\n        if (!this.isFormatElement(fel) && !this.isRangeFormatElement(fel) && !this.isComponent(fel)) {\n          withoutFormatCells.push(current);\n          return false;\n        }\n      }\n\n      var result = current.parentNode !== documentFragment && nrtag && (this.isListCell(current) && !this.isList(current.parentNode) || lowLevelCheck && (this.isFormatElement(current) || this.isComponent(current)) && !this.isRangeFormatElement(current.parentNode) && !this.getParentElement(current, this.isComponent));\n      return result;\n    }.bind(this));\n\n    for (var i = 0, len = removeTags.length; i < len; i++) {\n      this.removeItem(removeTags[i]);\n    }\n\n    var checkTags = [];\n\n    for (var _i4 = 0, _len2 = wrongTags.length, t, p; _i4 < _len2; _i4++) {\n      t = wrongTags[_i4];\n      p = t.parentNode;\n      if (!p || !p.parentNode) continue;\n\n      if (this.getParentElement(t, this.isListCell)) {\n        var cellChildren = t.childNodes;\n\n        for (var j = cellChildren.length - 1; _len2 >= 0; j--) {\n          p.insertBefore(t, cellChildren[j]);\n        }\n\n        checkTags.push(t);\n      } else {\n        p.parentNode.insertBefore(t, p);\n        checkTags.push(p);\n      }\n    }\n\n    for (var _i5 = 0, _len3 = checkTags.length, _t; _i5 < _len3; _i5++) {\n      _t = checkTags[_i5];\n\n      if (this.onlyZeroWidthSpace(_t.textContent.trim())) {\n        this.removeItem(_t);\n      }\n    }\n\n    for (var _i6 = 0, _len4 = emptyTags.length; _i6 < _len4; _i6++) {\n      this.removeItem(emptyTags[_i6]);\n    }\n\n    for (var _i7 = 0, _len5 = wrongList.length, _t2, tp, children, _p; _i7 < _len5; _i7++) {\n      _t2 = wrongList[_i7];\n      _p = _t2.parentNode;\n      if (!_p) continue;\n      tp = this.createElement('LI');\n\n      if (this.isFormatElement(_t2)) {\n        children = _t2.childNodes;\n\n        while (children[0]) {\n          tp.appendChild(children[0]);\n        }\n\n        _p.insertBefore(tp, _t2);\n\n        this.removeItem(_t2);\n      } else {\n        _t2 = _t2.nextSibling;\n        tp.appendChild(wrongList[_i7]);\n\n        _p.insertBefore(tp, _t2);\n      }\n    }\n\n    for (var _i8 = 0, _len6 = withoutFormatCells.length, _t3, f; _i8 < _len6; _i8++) {\n      _t3 = withoutFormatCells[_i8];\n      f = this.createElement('DIV');\n      f.innerHTML = _t3.textContent.trim().length === 0 && _t3.children.length === 0 ? '<br>' : _t3.innerHTML;\n      _t3.innerHTML = f.outerHTML;\n    }\n  },\n  _setDefaultOptionStyle: function _setDefaultOptionStyle(options, defaultStyle) {\n    var optionStyle = '';\n    if (options.height) optionStyle += 'height:' + options.height + ';';\n    if (options.minHeight) optionStyle += 'min-height:' + options.minHeight + ';';\n    if (options.maxHeight) optionStyle += 'max-height:' + options.maxHeight + ';';\n    if (options.position) optionStyle += 'position:' + options.position + ';';\n    if (options.width) optionStyle += 'width:' + options.width + ';';\n    if (options.minWidth) optionStyle += 'min-width:' + options.minWidth + ';';\n    if (options.maxWidth) optionStyle += 'max-width:' + options.maxWidth + ';';\n    var top = '',\n        frame = '',\n        editor = '';\n    defaultStyle = optionStyle + defaultStyle;\n    var styleArr = defaultStyle.split(';');\n\n    for (var i = 0, len = styleArr.length, s; i < len; i++) {\n      s = styleArr[i].trim();\n      if (!s) continue;\n\n      if (/^(min-|max-)?width\\s*:/.test(s) || /^(z-index|position)\\s*:/.test(s)) {\n        top += s + ';';\n        continue;\n      }\n\n      if (/^(min-|max-)?height\\s*:/.test(s)) {\n        if (/^height/.test(s) && s.split(':')[1].trim() === 'auto') {\n          options.height = 'auto';\n        }\n\n        frame += s + ';';\n        continue;\n      }\n\n      editor += s + ';';\n    }\n\n    return {\n      top: top,\n      frame: frame,\n      editor: editor\n    };\n  },\n  _setIframeDocument: function _setIframeDocument(frame, options) {\n    frame.setAttribute('scrolling', 'auto');\n    frame.contentDocument.head.innerHTML = '' + '<meta charset=\"utf-8\" />' + '<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">' + this._setIframeCssTags(options);\n    frame.contentDocument.body.className = options._editableClass;\n    frame.contentDocument.body.setAttribute('contenteditable', true);\n  },\n  _setIframeCssTags: function _setIframeCssTags(options) {\n    var linkNames = options.iframeCSSFileName;\n    var wRegExp = this._w.RegExp;\n    var tagString = '';\n\n    for (var f = 0, len = linkNames.length, path; f < len; f++) {\n      path = [];\n\n      if (/(^https?:\\/\\/)|(^data:text\\/css,)/.test(linkNames[f])) {\n        path.push(linkNames[f]);\n      } else {\n        var CSSFileName = new wRegExp('(^|.*[\\\\/])' + linkNames[f] + '(\\\\..+)?\\\\.css(?:\\\\?.*|;.*)?$', 'i');\n\n        for (var c = document.getElementsByTagName('link'), i = 0, _len7 = c.length, styleTag; i < _len7; i++) {\n          styleTag = c[i].href.match(CSSFileName);\n          if (styleTag) path.push(styleTag[0]);\n        }\n      }\n\n      if (!path || path.length === 0) throw '[SUNEDITOR.constructor.iframe.fail] The suneditor CSS files installation path could not be automatically detected. Please set the option property \"iframeCSSFileName\" before creating editor instances.';\n\n      for (var _i9 = 0, _len8 = path.length; _i9 < _len8; _i9++) {\n        tagString += '<link href=\"' + path[_i9] + '\" rel=\"stylesheet\">';\n      }\n    }\n\n    return tagString + (options.height === 'auto' ? '<style>\\n/** Iframe height auto */\\nbody{height: min-content; overflow: hidden;}\\n</style>' : '');\n  }\n};\nexport default util;","map":{"version":3,"sources":["E:/React/pos-system/main/node_modules/suneditor/src/lib/util.js"],"names":["util","_d","_w","isIE","isIE_Edge","isOSX_IOS","isChromium","_propertiesInit","document","window","navigator","userAgent","indexOf","appVersion","test","platform","chrome","_allowedEmptyNodeList","_HTMLConvertor","contents","ec","replace","m","zeroWidthSpace","String","fromCharCode","zeroWidthRegExp","RegExp","onlyZeroWidthRegExp","onlyZeroWidthSpace","text","undefined","textContent","getXMLHttpRequest","ActiveXObject","e","e1","XMLHttpRequest","getValues","obj","Object","keys","map","i","camelToKebabCase","param","letter","toLowerCase","str","kebabToCamelCase","toUpperCase","createElement","elementName","createTextNode","HTMLEncoder","HTMLDecoder","hasOwn","key","_hasOwn","call","prototype","hasOwnProperty","getIncludePath","nameArray","extension","path","pathList","tagName","src","fileName","len","length","regExp","extRegExp","c","getElementsByTagName","push","editorTag","match","slice","location","href","name","getPageStyle","doc","cssText","sheets","styleSheets","rules","cssRules","cLen","getIframeDocument","iframe","wDocument","contentWindow","contentDocument","getAttributesToString","element","exceptAttrs","attributes","attrs","attrString","value","getByteLength","toString","encoder","encodeURIComponent","cr","cl","unescape","TextEncoder","encode","isWysiwygDiv","nodeType","hasClass","nodeName","isNonEditable","getAttribute","isTextStyleElement","isFormatElement","isComponent","isRangeFormatElement","isClosureRangeFormatElement","isFreeFormatElement","isClosureFreeFormatElement","className","isUneditableComponent","isMediaComponent","isNotCheckingNode","getFormatElement","validation","firstElementChild","parentNode","getRangeFormatElement","getFreeFormatElement","getClosureFreeFormatElement","copyTagAttributes","originEl","copyEl","style","classes","classList","addClass","removeAttribute","trim","copyFormatAttributes","cloneNode","getArrayItem","array","multi","arr","a","arrayIncludes","getArrayIndex","idx","nextIdx","item","prevIdx","getPositionIndex","node","previousSibling","getNodePath","_newOffsets","finds","getParentElement","el","temp","tempText","s","previous","removeItem","next","nextSibling","bind","reverse","getNodeFromPath","offsets","current","nodes","childNodes","isSameAttributes","b","style_a","style_b","compStyle","class_a","class_b","reg","compClass","isEmptyLine","querySelector","isSpanWithoutAttr","isList","isListCell","isTable","isCell","isBreak","isAnchor","isMedia","isNumber","getNumber","maxDec","number","Math","round","toFixed","getListChildren","children","recursionFunc","getListChildNodes","getElementDepth","depth","compareElements","aNode","bNode","ancestor","result","aIndex","bIndex","query","check","attr","split","getChildElement","last","childList","getEdgeChildNodes","first","firstChild","lastChild","sc","getOffset","wysiwygFrame","offsetLeft","offsetTop","offsetElement","parentElement","wysiwyg","offsetParent","left","top","scrollTop","getOverlapRangeAtIndex","aStart","aEnd","bStart","bEnd","overlap","changeTxt","txt","changeElement","newElement","outerHTML","innerHTML","replaceChild","setStyle","styleName","removeClass","toggleClass","isImportantDisabled","hasAttribute","setDisabledButtons","disabled","buttonList","important","button","setAttribute","remove","removeChild","removeItemAllParents","stopParent","cc","parent","previousElementSibling","nextElementSibling","detachNestedList","baseNode","all","rNode","_deleteNestedList","rangeElement","cNodes","index","appendChild","rChildren","insertBefore","baseParent","sibling","liSibling","liParent","child","splitElement","offset","prev","bp","newEl","splitText","after","data","depthEl","pElement","mergeSameTags","mergeNestedTags","nodePathArray","onlyText","inst","nodePathLen","Array","apply","Number","valueOf","depthIndex","_isIgnoreNodeChange","p","cDepth","spliceDepth","n","splice","childs","childLength","nLen","l","r","addOffset","textOffset","tempL","removeEmptyNode","notRemoveNode","_notTextNode","htmlRemoveWhiteSpace","html","sortByDepth","des","t","f","sort","_isMaintainedNode","_isSizeNode","fontSize","_disallowedTags","createTagsWhitelist","list","createTagsBlacklist","_consistencyCheckOfHTML","documentFragment","htmlCheckWhitelistRegExp","htmlCheckBlacklistRegExp","lowLevelCheck","removeTags","emptyTags","wrongList","withoutFormatCells","wrongTags","nrtag","fel","checkTags","cellChildren","j","tp","_setDefaultOptionStyle","options","defaultStyle","optionStyle","height","minHeight","maxHeight","position","width","minWidth","maxWidth","frame","editor","styleArr","_setIframeDocument","head","_setIframeCssTags","body","_editableClass","linkNames","iframeCSSFileName","wRegExp","tagString","CSSFileName","styleTag"],"mappings":"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","sourcesContent":["/*\r\n * wysiwyg web editor\r\n *\r\n * suneditor.js\r\n * Copyright 2017 JiHong Lee.\r\n * MIT license.\r\n */\r\n'use strict';\r\n\r\n/**\r\n * @description utility function\r\n */\r\nconst util = {\r\n    _d: null,\r\n    _w: null,\r\n    isIE: null,\r\n    isIE_Edge: null,\r\n    isOSX_IOS: null,\r\n    isChromium: null,\r\n    _propertiesInit: function () {\r\n        if (this._d) return;\r\n        this._d =  document;\r\n        this._w = window;\r\n        this.isIE = navigator.userAgent.indexOf('Trident') > -1;\r\n        this.isIE_Edge = (navigator.userAgent.indexOf('Trident') > -1) || (navigator.appVersion.indexOf('Edge') > -1);\r\n        this.isOSX_IOS = /(Mac|iPhone|iPod|iPad)/.test(navigator.platform);\r\n        this.isChromium = !!window.chrome;\r\n    },\r\n\r\n    _allowedEmptyNodeList: '.se-component, pre, blockquote, hr, li, table, img, iframe, video, audio, canvas',\r\n\r\n    /**\r\n     * @description HTML Reserved Word Converter.\r\n     * @param {String} contents \r\n     * @returns {String} HTML string\r\n     * @private\r\n     */\r\n    _HTMLConvertor: function (contents) {\r\n        const ec = {'&': '&amp;', '\\u00A0': '&nbsp;', '\\'': '&apos;', '\"': '&quot;', '<': '&lt;', '>': '&gt;'};\r\n        return contents.replace(/&|\\u00A0|'|\"|<|>/g, function (m) {\r\n            return (typeof ec[m] === 'string') ? ec[m] : m;\r\n        });\r\n    },\r\n\r\n    /**\r\n     * @description Unicode Character 'ZERO WIDTH SPACE' (\\u200B)\r\n     */\r\n    zeroWidthSpace: String.fromCharCode(8203),\r\n\r\n    /**\r\n     * @description Regular expression to find 'zero width space' (/\\u200B/g)\r\n     */\r\n    zeroWidthRegExp: new RegExp(String.fromCharCode(8203), 'g'),\r\n\r\n    /**\r\n     * @description Regular expression to find only 'zero width space' (/^\\u200B+$/)\r\n     */\r\n    onlyZeroWidthRegExp: new RegExp('^' + String.fromCharCode(8203) + '+$'),\r\n\r\n    /**\r\n     * @description A method that checks If the text is blank or to see if it contains 'ZERO WIDTH SPACE' or empty (util.zeroWidthSpace)\r\n     * @param {String|Node} text String value or Node\r\n     * @returns {Boolean}\r\n     */\r\n    onlyZeroWidthSpace: function (text) {\r\n        if (text === null || text === undefined) return false;\r\n        if (typeof text !== 'string') text = text.textContent;\r\n        return text === '' || this.onlyZeroWidthRegExp.test(text);\r\n    },\r\n\r\n    /**\r\n     * @description Gets XMLHttpRequest object\r\n     * @returns {XMLHttpRequest|ActiveXObject}\r\n     */\r\n    getXMLHttpRequest: function () {\r\n        /** IE */\r\n        if (this._w.ActiveXObject) {\r\n            try {\r\n                return new ActiveXObject('Msxml2.XMLHTTP');\r\n            } catch (e) {\r\n                try {\r\n                    return new ActiveXObject('Microsoft.XMLHTTP');\r\n                } catch (e1) {\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n        /** netscape */\r\n        else if (this._w.XMLHttpRequest) {\r\n            return new XMLHttpRequest();\r\n        }\r\n        /** fail */\r\n        else {\r\n            return null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @description Object.values\r\n     * @param {Object|null} obj Object parameter.\r\n     * @returns {Array}\r\n     */\r\n    getValues: function (obj) {\r\n        return !obj ? [] : this._w.Object.keys(obj).map(function (i) {\r\n            return obj[i];\r\n        });\r\n    },\r\n\r\n    /**\r\n     * @description Convert the CamelCase To the KebabCase.\r\n     * @param {String|Array} param [Camel string]\r\n     * @returns {String|Array}\r\n     */\r\n    camelToKebabCase: function (param) {\r\n        if (typeof param === 'string') {\r\n            return param.replace(/[A-Z]/g, function (letter) { return \"-\" + letter.toLowerCase(); });\r\n        } else {\r\n            return param.map(function(str) { return util.camelToKebabCase(str); });\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @description Convert the KebabCase To the CamelCase.\r\n     * @param {String|Array} param [KebabCase string]\r\n     * @returns {String|Array}\r\n     */\r\n    kebabToCamelCase: function (param) {\r\n        if (typeof param === 'string') {\r\n            return param.replace(/-[a-zA-Z]/g, function (letter) { return letter.replace('-', '').toUpperCase(); });\r\n        } else {\r\n            return param.map(function(str) { return util.camelToKebabCase(str); });\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @description Create Element node\r\n     * @param {String} elementName Element name\r\n     * @returns {Element}\r\n     */\r\n    createElement: function (elementName) {\r\n        return this._d.createElement(elementName);\r\n    },\r\n\r\n    /**\r\n     * @description Create text node\r\n     * @param {String} text text contents\r\n     * @returns {Node}\r\n     */\r\n    createTextNode: function (text) {\r\n        return this._d.createTextNode(text || '');\r\n    },\r\n\r\n    /**\r\n     * @description The editor checks tags by string.\r\n     * If there is \"<\" or \">\" in the attribute of tag, HTML is broken when checking the tag.\r\n     * When using an attribute with \"<\" or \">\", use \"HTMLEncoder\" to save. (ex: math(katex))\r\n     * @param {String} contents HTML or Text string\r\n     * @returns {String}\r\n     */\r\n    HTMLEncoder: function (contents) {\r\n        const ec = {'<': '$lt;', '>': '$gt;'};\r\n        return contents.replace(/<|>/g, function (m) {\r\n            return (typeof ec[m] === 'string') ? ec[m] : m;\r\n        });\r\n    },\r\n\r\n    /**\r\n     * @description The editor checks tags by string.\r\n     * If there is \"<\" or \">\" in the attribute of tag, HTML is broken when checking the tag.\r\n     * Decoder of data stored as \"HTMLEncoder\" (ex: math(katex))\r\n     * @param {String} contents HTML or Text string\r\n     * @returns {String}\r\n     */\r\n    HTMLDecoder: function (contents) {\r\n        const ec = {'$lt;': '<', '$gt;': '>'};\r\n        return contents.replace(/\\$lt;|\\$gt;/g, function (m) {\r\n            return (typeof ec[m] === 'string') ? ec[m] : m;\r\n        });\r\n    },\r\n\r\n    /**\r\n     * @description This method run Object.prototype.hasOwnProperty.call(obj, key)\r\n     * @param {Object} obj Object\r\n     * @param {String} key obj.key\r\n     * @returns {Boolean}\r\n     */\r\n    hasOwn: function (obj, key) {\r\n        return this._hasOwn.call(obj, key);\r\n    },\r\n    _hasOwn: Object.prototype.hasOwnProperty,\r\n\r\n    /**\r\n     * @deprecated\r\n     * @description Get the the tag path of the arguments value\r\n     * If not found, return the first found value\r\n     * @param {Array} nameArray File name array\r\n     * @param {String} extension js, css\r\n     * @returns {String}\r\n     */\r\n    getIncludePath: function (nameArray, extension) {\r\n        let path = '';\r\n        const pathList = [];\r\n        const tagName = extension === 'js' ? 'script' : 'link';\r\n        const src = extension === 'js' ? 'src' : 'href';\r\n        \r\n        let fileName = '(?:';\r\n        for (let i = 0, len = nameArray.length; i < len; i++) {\r\n            fileName += nameArray[i] + (i < len - 1 ? '|' : ')');\r\n        }\r\n\r\n        const regExp = new this._w.RegExp('(^|.*[\\\\/])' + fileName + '(\\\\.[^\\\\/]+)?\\.' + extension + '(?:\\\\?.*|;.*)?$', 'i');\r\n        const extRegExp = new this._w.RegExp('.+\\\\.' + extension + '(?:\\\\?.*|;.*)?$', 'i');\r\n            \r\n        for (let c = this._d.getElementsByTagName(tagName), i = 0; i < c.length; i++) {\r\n            if (extRegExp.test(c[i][src])) {\r\n                pathList.push(c[i]);\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < pathList.length; i++) {\r\n            let editorTag = pathList[i][src].match(regExp);\r\n            if (editorTag) {\r\n                path = editorTag[0];\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (path === '') path = pathList.length > 0 ? pathList[0][src] : '';\r\n\r\n        -1 === path.indexOf(':/') && '//' !== path.slice(0, 2) && (path = 0 === path.indexOf('/') ? location.href.match(/^.*?:\\/\\/[^\\/]*/)[0] + path : location.href.match(/^[^\\?]*\\/(?:)/)[0] + path);\r\n\r\n        if (!path) throw '[SUNEDITOR.util.getIncludePath.fail] The SUNEDITOR installation path could not be automatically detected. (name: +' + name + ', extension: ' + extension + ')';\r\n\r\n        return path;\r\n    },\r\n\r\n    /**\r\n     * @deprecated\r\n     * @description Returns the CSS text that has been applied to the current page.\r\n     * @param {Document|null} doc To get the CSS text of an document(core._wd). If null get the current document.\r\n     * @returns {String} Styles string\r\n     */\r\n    getPageStyle: function (doc) {\r\n        let cssText = '';\r\n        const sheets = (doc || this._d).styleSheets;\r\n        \r\n        for (let i = 0, len = sheets.length, rules; i < len; i++) {\r\n            try {\r\n                rules = sheets[i].cssRules;\r\n            } catch (e) {\r\n                continue;\r\n            }\r\n            \r\n            if (rules) {\r\n                for (let c = 0, cLen = rules.length; c < cLen; c++) {\r\n                    cssText += rules[c].cssText;\r\n                }\r\n            }\r\n        }\r\n\r\n        return cssText;\r\n    },\r\n\r\n    /**\r\n     * @description Get the argument iframe's document object\r\n     * @param {Element} iframe Iframe element (context.element.wysiwygFrame)\r\n     * @returns {Document}\r\n     */\r\n    getIframeDocument: function (iframe) {\r\n        let wDocument = iframe.contentWindow || iframe.contentDocument;\r\n        if (wDocument.document) wDocument = wDocument.document;\r\n        return wDocument;\r\n    },\r\n\r\n    /**\r\n     * @description Get attributes of argument element to string ('class=\"---\" name=\"---\" ')\r\n     * @param {Element} element Element object\r\n     * @param {Array|null} exceptAttrs Array of attribute names to exclude from the result\r\n     * @returns {String}\r\n     */\r\n    getAttributesToString: function (element, exceptAttrs) {\r\n        if (!element.attributes) return '';\r\n\r\n        const attrs = element.attributes;\r\n        let attrString = '';\r\n\r\n        for (let i = 0, len = attrs.length; i < len; i++) {\r\n            if (exceptAttrs && exceptAttrs.indexOf(attrs[i].name) > -1) continue;\r\n            attrString += attrs[i].name + '=\"' + attrs[i].value + '\" ';\r\n        }\r\n\r\n        return attrString;\r\n    },\r\n\r\n    /**\r\n     * @descriptionGets Get the length in bytes of a string.\r\n     * referencing code: \"https://github.com/shaan1974/myrdin/blob/master/expressions/string.js#L11\"\r\n     * @param {String} text String text\r\n     * @returns {Number}\r\n     */\r\n    getByteLength: function(text) {\r\n        if (!text || !text.toString) return 0;\r\n        text = text.toString();\r\n\r\n        const encoder = this._w.encodeURIComponent;\r\n        let cr, cl;\r\n        if (this.isIE_Edge) {\r\n            cl = this._w.unescape(encoder(text)).length;\r\n            cr = 0;\r\n\r\n            if (encoder(text).match(/(%0A|%0D)/gi) !== null) {\r\n                cr = encoder(text).match(/(%0A|%0D)/gi).length;\r\n            }\r\n\r\n            return cl + cr;\r\n        } else {\r\n            cl = (new this._w.TextEncoder('utf-8').encode(text)).length;\r\n            cr = 0;\r\n\r\n            if (encoder(text).match(/(%0A|%0D)/gi) !== null) {\r\n                cr = encoder(text).match(/(%0A|%0D)/gi).length;\r\n            }\r\n\r\n            return cl + cr;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @description It is judged whether it is the edit region top div element or iframe's body tag.\r\n     * @param {Node} element The node to check\r\n     * @returns {Boolean}\r\n     */\r\n    isWysiwygDiv: function (element) {\r\n        return element && element.nodeType === 1 && (this.hasClass(element, 'se-wrapper-wysiwyg') || /^BODY$/i.test(element.nodeName));\r\n    },\r\n\r\n    /**\r\n     * @description It is judged whether it is the contenteditable property is false.\r\n     * @param {Node} element The node to check\r\n     * @returns {Boolean}\r\n     */\r\n    isNonEditable: function (element) {\r\n        return element && element.nodeType === 1 && element.getAttribute('contenteditable') === 'false';\r\n    },\r\n\r\n    /**\r\n     * @description It is judged whether it is a node related to the text style.\r\n     * (strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code)\r\n     * @param {Node} element The node to check\r\n     * @returns {Boolean}\r\n     */\r\n    isTextStyleElement: function (element) {\r\n        return element && element.nodeType !== 3 && /^(strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code|summary)$/i.test(element.nodeName);\r\n    },\r\n\r\n    /**\r\n     * @description It is judged whether it is the format element (P, DIV, H[1-6], PRE, LI | class=\"__se__format__replace_xxx\")\r\n     * Format element also contain \"free format Element\"\r\n     * @param {Node} element The node to check\r\n     * @returns {Boolean}\r\n     */\r\n    isFormatElement: function (element) {\r\n        return element && element.nodeType === 1 && (/^(P|DIV|H[1-6]|PRE|LI|TH|TD|DETAILS)$/i.test(element.nodeName) || this.hasClass(element, '(\\\\s|^)__se__format__replace_.+(\\\\s|$)|(\\\\s|^)__se__format__free_.+(\\\\s|$)')) && !this.isComponent(element) && !this.isWysiwygDiv(element);\r\n    },\r\n\r\n    /**\r\n     * @description It is judged whether it is the range format element. (BLOCKQUOTE, OL, UL, FIGCAPTION, TABLE, THEAD, TBODY, TR, TH, TD | class=\"__se__format__range_xxx\")\r\n     * Range format element is wrap the \"format element\" and \"component\"\r\n     * @param {Node} element The node to check\r\n     * @returns {Boolean}\r\n     */\r\n    isRangeFormatElement: function (element) {\r\n        return element && element.nodeType === 1 && (/^(BLOCKQUOTE|OL|UL|FIGCAPTION|TABLE|THEAD|TBODY|TR|TH|TD|DETAILS)$/i.test(element.nodeName) || this.hasClass(element, '(\\\\s|^)__se__format__range_.+(\\\\s|$)'));\r\n    },\r\n\r\n    /**\r\n     * @description It is judged whether it is the closure range format element. (TH, TD | class=\"__se__format__range__closure_xxx\")\r\n     * Closure range format elements is included in the range format element.\r\n     *  - Closure range format element is wrap the \"format element\" and \"component\"\r\n     * ※ You cannot exit this format with the Enter key or Backspace key.\r\n     * ※ Use it only in special cases. ([ex] format of table cells)\r\n     * @param {Node} element The node to check\r\n     * @returns {Boolean}\r\n     */\r\n    isClosureRangeFormatElement: function (element) {\r\n        return element && element.nodeType === 1 && (/^(TH|TD)$/i.test(element.nodeName) || this.hasClass(element, '(\\\\s|^)__se__format__range__closure_.+(\\\\s|$)'));\r\n    },\r\n\r\n    /**\r\n     * @description It is judged whether it is the free format element. (PRE | class=\"__se__format__free_xxx\")\r\n     * Free format elements is included in the format element.\r\n     * Free format elements's line break is \"BR\" tag.\r\n     * ※ Entering the Enter key in the space on the last line ends \"Free Format\" and appends \"Format\".\r\n     * @param {Node} element The node to check\r\n     * @returns {Boolean}\r\n     */\r\n    isFreeFormatElement: function (element) {\r\n        return element && element.nodeType === 1 && (/^PRE$/i.test(element.nodeName) || this.hasClass(element, '(\\\\s|^)__se__format__free_.+(\\\\s|$)')) && !this.isComponent(element) && !this.isWysiwygDiv(element);\r\n    },\r\n\r\n    /**\r\n     * @description It is judged whether it is the closure free format element. (class=\"__se__format__free__closure_xxx\")\r\n     * Closure free format elements is included in the free format element.\r\n     *  - Closure free format elements's line break is \"BR\" tag.\r\n     * ※ You cannot exit this format with the Enter key or Backspace key.\r\n     * ※ Use it only in special cases. ([ex] format of table cells)\r\n     * @param {Node} element The node to check\r\n     * @returns {Boolean}\r\n     */\r\n    isClosureFreeFormatElement: function (element) {\r\n        return element && element.nodeType === 1 && this.hasClass(element, '(\\\\s|^)__se__format__free__closure_.+(\\\\s|$)');\r\n    },\r\n\r\n    /**\r\n     * @description It is judged whether it is the component[img, iframe, video, audio, table] cover(class=\"se-component\") and table, hr\r\n     * @param {Node} element The node to check\r\n     * @returns {Boolean}\r\n     */\r\n    isComponent: function (element) {\r\n        return element && (/se-component/.test(element.className) || /^(TABLE|HR)$/.test(element.nodeName));\r\n    },\r\n\r\n    /**\r\n     * @description Checks for \"__se__uneditable\" in the class list.\r\n     * Components with class \"__se__uneditable\" cannot be modified.\r\n     * @param {Element} element The element to check\r\n     * @returns {Boolean}\r\n     */\r\n    isUneditableComponent: function (element) {\r\n        return element && this.hasClass(element, '__se__uneditable');\r\n    },\r\n\r\n    /**\r\n     * @description It is judged whether it is the component [img, iframe] cover(class=\"se-component\")\r\n     * @param {Node} element The node to check\r\n     * @returns {Boolean}\r\n     */\r\n    isMediaComponent: function (element) {\r\n        return element && /se-component/.test(element.className);\r\n    },\r\n\r\n    /**\r\n     * @description It is judged whether it is the not checking node. (class=\"katex\", \"__se__tag\")\r\n     * @param {Node} element The node to check\r\n     * @returns {Boolean}\r\n     */\r\n    isNotCheckingNode: function (element) {\r\n        return element && /katex|__se__tag/.test(element.className);\r\n    },\r\n\r\n    /**\r\n     * @description If a parent node that contains an argument node finds a format node (util.isFormatElement), it returns that node.\r\n     * @param {Node} element Reference node.\r\n     * @param {Function|null} validation Additional validation function.\r\n     * @returns {Element|null}\r\n     */\r\n    getFormatElement: function (element, validation) {\r\n        if (!element) return null;\r\n        if (!validation) {\r\n            validation = function () { return true; };\r\n        }\r\n\r\n        while (element) {\r\n            if (this.isWysiwygDiv(element)) return null;\r\n            if (this.isRangeFormatElement(element)) element.firstElementChild;\r\n            if (this.isFormatElement(element) && validation(element)) return element;\r\n\r\n            element = element.parentNode;\r\n        }\r\n        \r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * @description If a parent node that contains an argument node finds a format node (util.isRangeFormatElement), it returns that node.\r\n     * @param {Node} element Reference node.\r\n     * @param {Function|null} validation Additional validation function.\r\n     * @returns {Element|null}\r\n     */\r\n    getRangeFormatElement: function (element, validation) {\r\n        if (!element) return null;\r\n        if (!validation) {\r\n            validation = function () { return true; };\r\n        }\r\n\r\n        while (element) {\r\n            if (this.isWysiwygDiv(element)) return null;\r\n            if (this.isRangeFormatElement(element) && !/^(THEAD|TBODY|TR)$/i.test(element.nodeName) && validation(element)) return element;\r\n            element = element.parentNode;\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * @description If a parent node that contains an argument node finds a free format node (util.isFreeFormatElement), it returns that node.\r\n     * @param {Node} element Reference node.\r\n     * @param {Function|null} validation Additional validation function.\r\n     * @returns {Element|null}\r\n     */\r\n    getFreeFormatElement: function (element, validation) {\r\n        if (!element) return null;\r\n        if (!validation) {\r\n            validation = function () { return true; };\r\n        }\r\n\r\n        while (element) {\r\n            if (this.isWysiwygDiv(element)) return null;\r\n            if (this.isFreeFormatElement(element) && validation(element)) return element;\r\n\r\n            element = element.parentNode;\r\n        }\r\n        \r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * @description If a parent node that contains an argument node finds a closure free format node (util.isClosureFreeFormatElement), it returns that node.\r\n     * @param {Node} element Reference node.\r\n     * @param {Function|null} validation Additional validation function.\r\n     * @returns {Element|null}\r\n     */\r\n    getClosureFreeFormatElement: function (element, validation) {\r\n        if (!element) return null;\r\n        if (!validation) {\r\n            validation = function () { return true; };\r\n        }\r\n\r\n        while (element) {\r\n            if (this.isWysiwygDiv(element)) return null;\r\n            if (this.isClosureFreeFormatElement(element) && validation(element)) return element;\r\n\r\n            element = element.parentNode;\r\n        }\r\n        \r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * @description Add style and className of copyEl to originEl\r\n     * @param {Element} originEl Origin element\r\n     * @param {Element} copyEl Element to copy\r\n     */\r\n    copyTagAttributes: function (originEl, copyEl) {\r\n        if (copyEl.style.cssText) {\r\n            originEl.style.cssText += copyEl.style.cssText;\r\n        }\r\n\r\n        const classes = copyEl.classList;\r\n        for (let i = 0, len = classes.length; i < len; i++) {\r\n            this.addClass(originEl, classes[i]);\r\n        }\r\n\r\n        if (!originEl.style.cssText) originEl.removeAttribute('style');\r\n        if (!originEl.className.trim()) originEl.removeAttribute('class');\r\n    },\r\n\r\n    /**\r\n     * @description Copy and apply attributes of format tag that should be maintained. (style, class) Ignore \"__se__format__\" class\r\n     * @param {Element} originEl Origin element\r\n     * @param {Element} copyEl Element to copy\r\n     */\r\n    copyFormatAttributes: function (originEl, copyEl) {\r\n        copyEl = copyEl.cloneNode(false);\r\n        copyEl.className = copyEl.className.replace(/(\\s|^)__se__format__[^\\s]+/g, '');\r\n        this.copyTagAttributes(originEl, copyEl);\r\n    },\r\n\r\n    /**\r\n     * @description Get the item from the array that matches the condition.\r\n     * @param {Array|HTMLCollection|NodeList} array Array to get item\r\n     * @param {Function|null} validation Conditional function\r\n     * @param {Boolean} multi If true, returns all items that meet the criteria otherwise, returns an empty array.\r\n     * If false, returns only one item that meet the criteria otherwise return null.\r\n     * @returns {Array|Node|null}\r\n     */\r\n    getArrayItem: function (array, validation, multi) {\r\n        if (!array || array.length === 0) return null;\r\n\r\n        validation = validation || function () { return true; };\r\n        const arr = [];\r\n        \r\n        for (let i = 0, len = array.length, a; i < len; i++) {\r\n            a = array[i];\r\n            if (validation(a)) {\r\n                if (!multi) return a;\r\n                else arr.push(a);\r\n            }\r\n        }\r\n\r\n        return !multi ? null : arr;\r\n    },\r\n\r\n    /**\r\n     * @description Check if an array contains an element \r\n     * @param {Array|HTMLCollection|NodeList} array element array\r\n     * @param {Node} element The element to check for\r\n     * @returns {Boolean}\r\n     */\r\n    arrayIncludes: function(array, element) {\r\n        for (let i = 0; i < array.length; i++) {\r\n            if (array[i] === element) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * @description Get the index of the argument value in the element array\r\n     * @param {Array|HTMLCollection|NodeList} array element array\r\n     * @param {Node} element The element to find index\r\n     * @returns {Number}\r\n     */\r\n    getArrayIndex: function (array, element) {\r\n        let idx = -1;\r\n        for (let i = 0, len = array.length; i < len; i++) {\r\n            if (array[i] === element) {\r\n                idx = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return idx;\r\n    },\r\n\r\n    /**\r\n     * @description Get the next index of the argument value in the element array\r\n     * @param {Array|HTMLCollection|NodeList} array element array\r\n     * @param {Node} item The element to find index\r\n     * @returns {Number}\r\n     */\r\n    nextIdx: function (array, item) {\r\n        let idx = this.getArrayIndex(array, item);\r\n        if (idx === -1) return -1;\r\n        return idx + 1;\r\n    },\r\n\r\n    /**\r\n     * @description Get the previous index of the argument value in the element array\r\n     * @param {Array|HTMLCollection|NodeList} array Element array\r\n     * @param {Node} item The element to find index\r\n     * @returns {Number}\r\n     */\r\n    prevIdx: function (array, item) {\r\n        let idx = this.getArrayIndex(array, item);\r\n        if (idx === -1) return -1;\r\n        return idx - 1;\r\n    },\r\n\r\n    /**\r\n     * @description Returns the index compared to other sibling nodes.\r\n     * @param {Node} node The Node to find index\r\n     * @returns {Number}\r\n     */\r\n    getPositionIndex: function (node) {\r\n        let idx = 0;\r\n        while ((node = node.previousSibling)) {\r\n            idx += 1;\r\n        }\r\n        return idx;\r\n    },\r\n\r\n    /**\r\n     * @description Returns the position of the \"node\" in the \"parentNode\" in a numerical array.\r\n     * ex) <p><span>aa</span><span>bb</span></p> : getNodePath(node: \"bb\", parentNode: \"<P>\") -> [1, 0]\r\n     * @param {Node} node The Node to find position path\r\n     * @param {Node|null} parentNode Parent node. If null, wysiwyg div area\r\n     * @param {Object|null} _newOffsets If you send an object of the form \"{s: 0, e: 0}\", the text nodes that are attached together are merged into one, centered on the \"node\" argument.\r\n     * \"_newOffsets.s\" stores the length of the combined characters after \"node\" and \"_newOffsets.e\" stores the length of the combined characters before \"node\".\r\n     * Do not use unless absolutely necessary.\r\n     * @returns {Array}\r\n     */\r\n    getNodePath: function (node, parentNode, _newOffsets) {\r\n        const path = [];\r\n        let finds = true;\r\n\r\n        this.getParentElement(node, function (el) {\r\n            if (el === parentNode) finds = false;\r\n            if (finds && !this.isWysiwygDiv(el)) {\r\n                // merge text nodes\r\n                if (_newOffsets && el.nodeType === 3) {\r\n                    let temp = null, tempText = null;\r\n                    _newOffsets.s = _newOffsets.e = 0;\r\n\r\n                    let previous = el.previousSibling;\r\n                    while (previous && previous.nodeType === 3) {\r\n                        tempText = previous.textContent.replace(this.zeroWidthRegExp, '');\r\n                        _newOffsets.s += tempText.length;\r\n                        el.textContent = tempText + el.textContent;\r\n                        temp = previous;\r\n                        previous = previous.previousSibling;\r\n                        this.removeItem(temp);\r\n                    }\r\n\r\n                    let next = el.nextSibling;\r\n                    while (next && next.nodeType === 3) {\r\n                        tempText = next.textContent.replace(this.zeroWidthRegExp, '');\r\n                        _newOffsets.e += tempText.length;\r\n                        el.textContent += tempText;\r\n                        temp = next;\r\n                        next = next.nextSibling;\r\n                        this.removeItem(temp);\r\n                    }\r\n                }\r\n\r\n                // index push\r\n                path.push(el);\r\n            }\r\n            return false;\r\n        }.bind(this));\r\n        \r\n        return path.map(this.getPositionIndex).reverse();\r\n    },\r\n\r\n    /**\r\n     * @description Returns the node in the location of the path array obtained from \"util.getNodePath\".\r\n     * @param {Array} offsets Position array, array obtained from \"util.getNodePath\"\r\n     * @param {Node} parentNode Base parent element\r\n     * @returns {Node}\r\n     */\r\n    getNodeFromPath: function (offsets, parentNode) {\r\n        let current = parentNode;\r\n        let nodes;\r\n\r\n        for (let i = 0, len = offsets.length; i < len; i++) {\r\n            nodes = current.childNodes;\r\n            if (nodes.length === 0) break;\r\n            if (nodes.length <= offsets[i]) {\r\n                current = nodes[nodes.length - 1];\r\n            } else {\r\n                current = nodes[offsets[i]];\r\n            }\r\n        }\r\n\r\n        return current;\r\n    },\r\n\r\n    /**\r\n     * @description Compares the style and class for equal values.\r\n     * Returns true if both are text nodes.\r\n     * @param {Node} a Node to compare\r\n     * @param {Node} b Node to compare\r\n     * @returns {Boolean}\r\n     */\r\n    isSameAttributes: function (a, b) {\r\n        if (a.nodeType === 3 && b.nodeType === 3) return true;\r\n        if (a.nodeType === 3 || b.nodeType === 3) return false;\r\n\r\n        const style_a = a.style;\r\n        const style_b = b.style;\r\n        let compStyle = 0;\r\n\r\n        for (let i = 0, len = style_a.length; i < len; i++) {\r\n            if (style_a[style_a[i]] === style_b[style_a[i]]) compStyle++;\r\n        }\r\n\r\n        const class_a = a.classList;\r\n        const class_b = b.classList;\r\n        const reg = this._w.RegExp;\r\n        let compClass = 0;\r\n\r\n        for (let i = 0, len = class_a.length; i < len; i++) {\r\n            if (reg('(\\s|^)' + class_a[i] + '(\\s|$)').test(class_b.value)) compClass++;\r\n        }\r\n\r\n        return (compStyle === style_b.length && compStyle === style_a.length) && (compClass === class_b.length && compClass === class_a.length);\r\n    },\r\n\r\n    /**\r\n     * @description Check the line element(util.isFormatElement) is empty.\r\n     * @param {Element} element Format element node\r\n     * @returns {Boolean}\r\n     */\r\n    isEmptyLine: function (element) {\r\n        return !element || !element.parentNode || (!element.querySelector('IMG, IFRAME, AUDIO, VIDEO, CANVAS, TABLE') && this.onlyZeroWidthSpace(element.textContent));\r\n    },\r\n\r\n    /**\r\n     * @description Check the span's attributes are empty.\r\n     * @param {Element|null} element Element node\r\n     * @returns {Boolean}\r\n     */\r\n    isSpanWithoutAttr: function (element) {\r\n        return !!element && element.nodeType === 1 && /^SPAN$/i.test(element.nodeName) && !element.className && !element.style.cssText;\r\n    },\r\n\r\n    /**\r\n     * @description Check the node is a list (ol, ul)\r\n     * @param {Node|String} node The element or element name to check\r\n     * @returns {Boolean}\r\n     */\r\n    isList: function (node) {\r\n        return node && /^(OL|UL)$/i.test(typeof node === 'string' ? node : node.nodeName);\r\n    },\r\n\r\n    /**\r\n     * @description Check the node is a list cell (li)\r\n     * @param {Node|String} node The element or element name to check\r\n     * @returns {Boolean}\r\n     */\r\n    isListCell: function (node) {\r\n        return node && /^LI$/i.test(typeof node === 'string' ? node : node.nodeName);\r\n    },\r\n\r\n    /**\r\n     * @description Check the node is a table (table, thead, tbody, tr, th, td)\r\n     * @param {Node|String} node The element or element name to check\r\n     * @returns {Boolean}\r\n     */\r\n    isTable: function (node) {\r\n        return node && /^(TABLE|THEAD|TBODY|TR|TH|TD)$/i.test(typeof node === 'string' ? node : node.nodeName);\r\n    },\r\n\r\n    /**\r\n     * @description Check the node is a table cell (td, th)\r\n     * @param {Node|String} node The element or element name to check\r\n     * @returns {Boolean}\r\n     */\r\n    isCell: function (node) {\r\n        return node && /^(TD|TH)$/i.test(typeof node === 'string' ? node : node.nodeName);\r\n    },\r\n\r\n    /**\r\n     * @description Check the node is a break node (BR)\r\n     * @param {Node|String} node The element or element name to check\r\n     * @returns {Boolean}\r\n     */\r\n    isBreak: function (node) {\r\n        return node && /^BR$/i.test(typeof node === 'string' ? node : node.nodeName);\r\n    },\r\n\r\n\r\n    /**\r\n     * @description Check the node is a anchor node (A)\r\n     * @param {Node|String} node The element or element name to check\r\n     * @returns {Boolean}\r\n     */\r\n    isAnchor: function (node) {\r\n        return node && /^A$/i.test(typeof node === 'string' ? node : node.nodeName);\r\n    },\r\n\r\n    /**\r\n     * @description Check the node is a media node (img, iframe, audio, video, canvas)\r\n     * @param {Node|String} node The element or element name to check\r\n     * @returns {Boolean}\r\n     */\r\n    isMedia: function (node) {\r\n        return node && /^(IMG|IFRAME|AUDIO|VIDEO|CANVAS)$/i.test(typeof node === 'string' ? node : node.nodeName);\r\n    },\r\n\r\n    /**\r\n     * @description Checks for numeric (with decimal point).\r\n     * @param {String|Number} text Text string or number\r\n     * @returns {Boolean}\r\n     */\r\n    isNumber: function (text) {\r\n        return !!text && /^-?\\d+(\\.\\d+)?$/.test(text + '');\r\n    },\r\n\r\n    /**\r\n     * @description Get a number.\r\n     * @param {String|Number} text Text string or number\r\n     * @param {Number} maxDec Maximum number of decimal places (-1 : Infinity)\r\n     * @returns {Number}\r\n     */\r\n    getNumber: function (text, maxDec) {\r\n        if (!text) return 0;\r\n        \r\n        let number = (text + '').match(/-?\\d+(\\.\\d+)?/);\r\n        if (!number || !number[0]) return 0;\r\n\r\n        number = number[0];\r\n        return maxDec < 0 ? number * 1 : maxDec === 0 ? this._w.Math.round(number * 1) : (number * 1).toFixed(maxDec) * 1;\r\n    },\r\n\r\n    /**\r\n     * @description Get all \"children\" of the argument value element (Without text nodes)\r\n     * @param {Element} element element to get child node\r\n     * @param {Function|null} validation Conditional function\r\n     * @returns {Array}\r\n     */\r\n    getListChildren: function (element, validation) {\r\n        const children = [];\r\n        if (!element || !element.children || element.children.length === 0) return children;\r\n\r\n        validation = validation || function () { return true; };\r\n\r\n        (function recursionFunc(current) {\r\n            if (element !== current && validation(current)) {\r\n                children.push(current);\r\n            }\r\n\r\n            if (!!current.children) {\r\n                for (let i = 0, len = current.children.length; i < len; i++) {\r\n                    recursionFunc(current.children[i]);\r\n                }\r\n            }\r\n        })(element);\r\n\r\n        return children;\r\n    },\r\n\r\n    /**\r\n     * @description Get all \"childNodes\" of the argument value element (Include text nodes)\r\n     * @param {Node} element element to get child node\r\n     * @param {Function|null} validation Conditional function\r\n     * @returns {Array}\r\n     */\r\n    getListChildNodes: function (element, validation) {\r\n        const children = [];\r\n        if (!element || element.childNodes.length === 0) return children;\r\n\r\n        validation = validation || function () { return true; };\r\n\r\n        (function recursionFunc(current) {\r\n            if (element !== current && validation(current)) {\r\n                children.push(current);\r\n            }\r\n\r\n            for (let i = 0, len = current.childNodes.length; i < len; i++) {\r\n                recursionFunc(current.childNodes[i]);\r\n            }\r\n        })(element);\r\n\r\n        return children;\r\n    },\r\n\r\n    /**\r\n     * @description Returns the number of parents nodes.\r\n     * \"0\" when the parent node is the WYSIWYG area.\r\n     * \"-1\" when the element argument is the WYSIWYG area.\r\n     * @param {Node} element The element to check\r\n     * @returns {Number}\r\n     */\r\n    getElementDepth: function (element) {\r\n        if (!element || this.isWysiwygDiv(element)) return -1;\r\n\r\n        let depth = 0;\r\n        element = element.parentNode;\r\n\r\n        while (element && !this.isWysiwygDiv(element)) {\r\n            depth += 1;\r\n            element = element.parentNode;\r\n        }\r\n\r\n        return depth;\r\n    },\r\n\r\n    /**\r\n     * @description Compares two elements to find a common ancestor, and returns the order of the two elements.\r\n     * @param {Node} a Node to compare.\r\n     * @param {Node} b Node to compare.\r\n     * @returns {Object} { ancesstor, a, b, result: (a > b ? 1 : a < b ? -1 : 0) };\r\n     */\r\n    compareElements: function (a, b) {\r\n        let aNode = a, bNode = b;\r\n        while (aNode && bNode && aNode.parentNode !== bNode.parentNode) {\r\n            aNode = aNode.parentNode;\r\n            bNode = bNode.parentNode;\r\n        }\r\n\r\n        if (!aNode || !bNode) return { ancestor: null, a: a, b: b, result: 0 };\r\n\r\n        const children = aNode.parentNode.childNodes;\r\n        const aIndex = this.getArrayIndex(children, aNode);\r\n        const bIndex = this.getArrayIndex(children, bNode);\r\n\r\n        return {\r\n            ancestor: aNode.parentNode,\r\n            a: aNode,\r\n            b: bNode,\r\n            result: aIndex > bIndex ? 1 : aIndex < bIndex ? -1 : 0\r\n        };\r\n    },\r\n\r\n    /**\r\n     * @description Get the parent element of the argument value.\r\n     * A tag that satisfies the query condition is imported.\r\n     * Returns null if not found.\r\n     * @param {Node} element Reference element\r\n     * @param {String|Function} query Query String (nodeName, .className, #ID, :name) or validation function.\r\n     * Not use it like jquery.\r\n     * Only one condition can be entered at a time.\r\n     * @returns {Element|null}\r\n     */\r\n    getParentElement: function (element, query) {\r\n        let check;\r\n\r\n        if (typeof query === 'function') {\r\n            check = query;\r\n        } else {\r\n            let attr;\r\n            if (/^\\./.test(query)) {\r\n                attr = 'className';\r\n                query = query.split('.')[1];\r\n            } else if (/^#/.test(query)) {\r\n                attr = 'id';\r\n                query = '^' + query.split('#')[1] + '$';\r\n            } else if (/^:/.test(query)) {\r\n                attr = 'name';\r\n                query = '^' + query.split(':')[1] + '$';\r\n            } else {\r\n                attr = 'nodeName';\r\n                query = '^' + query + '$';\r\n            }\r\n\r\n            const regExp = new this._w.RegExp(query, 'i');\r\n            check = function (el) {\r\n                return regExp.test(el[attr]);\r\n            };\r\n        }\r\n\r\n        while (element && !check(element)) {\r\n            if (this.isWysiwygDiv(element)) {\r\n                return null;\r\n            }\r\n            element = element.parentNode;\r\n        }\r\n\r\n        return element;\r\n    },\r\n\r\n    /**\r\n     * @description Get the child element of the argument value.\r\n     * A tag that satisfies the query condition is imported.\r\n     * Returns null if not found.\r\n     * @param {Node} element Reference element\r\n     * @param {String|Function} query Query String (nodeName, .className, #ID, :name) or validation function.\r\n     * @param {Boolean} last If true returns the last node among the found child nodes. (default: first node)\r\n     * Not use it like jquery.\r\n     * Only one condition can be entered at a time.\r\n     * @returns {Element|null}\r\n     */\r\n    getChildElement: function (element, query, last) {\r\n        let check;\r\n\r\n        if (typeof query === 'function') {\r\n            check = query;\r\n        } else {\r\n            let attr;\r\n            if (/^\\./.test(query)) {\r\n                attr = 'className';\r\n                query = query.split('.')[1];\r\n            } else if (/^#/.test(query)) {\r\n                attr = 'id';\r\n                query = '^' + query.split('#')[1] + '$';\r\n            } else if (/^:/.test(query)) {\r\n                attr = 'name';\r\n                query = '^' + query.split(':')[1] + '$';\r\n            } else {\r\n                attr = 'nodeName';\r\n                query = '^' + (query === 'text' ? '#' + query : query) + '$';\r\n            }\r\n\r\n            const regExp = new this._w.RegExp(query, 'i');\r\n            check = function (el) {\r\n                return regExp.test(el[attr]);\r\n            };\r\n        }\r\n\r\n        const childList = this.getListChildNodes(element, function (current) {\r\n            return check(current);\r\n        });\r\n\r\n        return childList[last ? childList.length - 1 : 0];\r\n    },\r\n\r\n    /**\r\n     * @description 1. The first node of all the child nodes of the \"first\" element is returned.\r\n     * 2. The last node of all the child nodes of the \"last\" element is returned.\r\n     * 3. When there is no \"last\" element, the first and last nodes of all the children of the \"first\" element are returned.\r\n     * { sc: \"first\", ec: \"last\" }\r\n     * @param {Node} first First element\r\n     * @param {Node|null} last Last element\r\n     * @returns {Object}\r\n     */\r\n    getEdgeChildNodes: function (first, last) {\r\n        if (!first) return;\r\n        if (!last) last = first;\r\n\r\n        while (first && first.nodeType === 1 && first.childNodes.length > 0 && !this.isBreak(first)) first = first.firstChild;\r\n        while (last && last.nodeType === 1 && last.childNodes.length > 0 &&  !this.isBreak(last)) last = last.lastChild;\r\n\r\n        return {\r\n            sc: first,\r\n            ec: last || first\r\n        };\r\n    },\r\n\r\n    /**\r\n     * @description Returns the position of the left and top of argument. {left:0, top:0}\r\n     * @param {Node} element Target node\r\n     * @param {Element|null} wysiwygFrame When use iframe option, iframe object should be sent (context.element.wysiwygFrame)\r\n     * @returns {Object}\r\n     */\r\n    getOffset: function (element, wysiwygFrame) {\r\n        let offsetLeft = 0;\r\n        let offsetTop = 0;\r\n        let offsetElement = element.nodeType === 3 ? element.parentElement : element;\r\n        const wysiwyg = this.getParentElement(element, this.isWysiwygDiv.bind(this));\r\n\r\n        while (offsetElement && !this.hasClass(offsetElement, 'se-container') && offsetElement !== wysiwyg) {\r\n            offsetLeft += offsetElement.offsetLeft;\r\n            offsetTop += offsetElement.offsetTop;\r\n            offsetElement = offsetElement.offsetParent;\r\n        }\r\n\r\n        const iframe = wysiwygFrame && /iframe/i.test(wysiwygFrame.nodeName);\r\n\r\n        return {\r\n            left: offsetLeft + (iframe ? wysiwygFrame.parentElement.offsetLeft : 0),\r\n            top: (offsetTop - (wysiwyg ? wysiwyg.scrollTop : 0)) + (iframe ? wysiwygFrame.parentElement.offsetTop : 0)\r\n        };\r\n    },\r\n\r\n    /**\r\n     * @description It compares the start and end indexes of \"a\" and \"b\" and returns the number of overlapping indexes in the range.\r\n     * ex) 1, 5, 4, 6 => \"2\" (4 ~ 5)\r\n     * @param {Number} aStart Start index of \"a\"\r\n     * @param {Number} aEnd End index of \"a\"\r\n     * @param {Number} bStart Start index of \"b\"\r\n     * @param {Number} bEnd Start index of \"b\"\r\n     * @returns {Number}\r\n     */\r\n    getOverlapRangeAtIndex: function (aStart, aEnd, bStart, bEnd) {\r\n        if (aStart <= bEnd ? aEnd < bStart : aEnd > bStart) return 0;\r\n\r\n        const overlap = (aStart > bStart ? aStart : bStart) - (aEnd < bEnd ? aEnd : bEnd);\r\n        return (overlap < 0 ? overlap * -1 : overlap) + 1;\r\n    },\r\n\r\n    /**\r\n     * @description Set the text content value of the argument value element\r\n     * @param {Node} element Element to replace text content\r\n     * @param {String} txt Text to be applied\r\n     */\r\n    changeTxt: function (element, txt) {\r\n        if (!element || !txt) return;\r\n        element.textContent = txt;\r\n    },\r\n\r\n    /**\r\n     * @description Replace element\r\n     * @param {Element} element Target element\r\n     * @param {String|Element} newElement String or element of the new element to apply\r\n     */\r\n    changeElement: function (element, newElement) {\r\n        if (typeof newElement === 'string') {\r\n            if (element.outerHTML) {\r\n                element.outerHTML = newElement;\r\n            } else {\r\n                const doc = this.createElement('DIV');\r\n                doc.innerHTML = newElement;\r\n                newElement = doc.firstChild;\r\n                element.parentNode.replaceChild(newElement, element);\r\n            }\r\n        } else if (newElement.nodeType === 1) {\r\n            element.parentNode.replaceChild(newElement, element);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @description Set style, if all styles are deleted, the style properties are deleted.\r\n     * @param {Element} element Element to set style\r\n     * @param {String} styleName Style attribute name (marginLeft, textAlign...)\r\n     * @param {String|Number} value Style value\r\n     */\r\n    setStyle: function (element, styleName, value) {\r\n        element.style[styleName] = value;\r\n\r\n        if (!value && !element.style.cssText) {\r\n            element.removeAttribute('style');\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @description Determine whether any of the matched elements are assigned the given class\r\n     * @param {Element} element Elements to search class name\r\n     * @param {String} className Class name to search for\r\n     * @returns {Boolean}\r\n     */\r\n    hasClass: function (element, className) {\r\n        if (!element) return;\r\n\r\n        return (new this._w.RegExp(className)).test(element.className);\r\n    },\r\n\r\n    /**\r\n     * @description Append the className value of the argument value element\r\n     * @param {Element} element Elements to add class name\r\n     * @param {String} className Class name to be add\r\n     */\r\n    addClass: function (element, className) {\r\n        if (!element) return;\r\n\r\n        const check = new this._w.RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\r\n        if (check.test(element.className)) return;\r\n\r\n        element.className += (element.className.length > 0 ? ' ' : '') + className;\r\n    },\r\n\r\n    /**\r\n     * @description Delete the className value of the argument value element\r\n     * @param {Element} element Elements to remove class name\r\n     * @param {String} className Class name to be remove\r\n     */\r\n    removeClass: function (element, className) {\r\n        if (!element) return;\r\n\r\n        const check = new this._w.RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\r\n        element.className = element.className.replace(check, ' ').trim();\r\n\r\n        if (!element.className.trim()) element.removeAttribute('class');\r\n    },\r\n\r\n    /**\r\n     * @description Argument value If there is no class name, insert it and delete the class name if it exists\r\n     * @param {Element} element Elements to replace class name\r\n     * @param {String} className Class name to be change\r\n     * @returns {Boolean|undefined}\r\n     */\r\n    toggleClass: function (element, className) {\r\n        if (!element) return;\r\n        let result = false;\r\n\r\n        const check = new this._w.RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\r\n        if (check.test(element.className)) {\r\n            element.className = element.className.replace(check, ' ').trim();\r\n        } else {\r\n            element.className += ' ' + className;\r\n            result = true;\r\n        }\r\n\r\n        if (!element.className.trim()) element.removeAttribute('class');\r\n\r\n        return result;\r\n    },\r\n\r\n    /**\r\n     * @description Checks if element can't be easily enabled\r\n     * @param {Element} element Element to check for\r\n     */\r\n    isImportantDisabled: function (element) {\r\n        return element.hasAttribute('data-important-disabled');\r\n    },\r\n\r\n    /**\r\n     * @description In the predefined code view mode, the buttons except the executable button are changed to the 'disabled' state.\r\n     * core.codeViewDisabledButtons (An array of buttons whose class name is not \"se-code-view-enabled\")\r\n     * core.resizingDisabledButtons (An array of buttons whose class name is not \"se-resizing-enabled\")\r\n     * @param {Boolean} disabled Disabled value\r\n     * @param {Array|HTMLCollection|NodeList} buttonList Button array\r\n     * @param {Boolean} important If priveleged mode should be used (Necessary to switch importantDisabled buttons)\r\n     */\r\n    setDisabledButtons: function (disabled, buttonList, important) {\r\n        for (let i = 0, len = buttonList.length; i < len; i++) {\r\n            let button = buttonList[i];\r\n            if (important || !this.isImportantDisabled(button)) button.disabled = disabled;\r\n            if (important) {\r\n                if (disabled) { \r\n                    button.setAttribute('data-important-disabled', '');\r\n                } else {\r\n                    button.removeAttribute('data-important-disabled');\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * @description Delete argumenu value element\r\n     * @param {Node} item Node to be remove\r\n     */\r\n    removeItem: function (item) {\r\n        if (!item) return;\r\n\r\n        if(typeof item.remove === 'function') item.remove();\r\n        else if (item.parentNode) item.parentNode.removeChild(item);\r\n    },\r\n\r\n    /**\r\n     * @description Delete all parent nodes that match the condition.\r\n     * Returns an {sc: previousSibling, ec: nextSibling}(the deleted node reference) or null.\r\n     * @param {Node} item Node to be remove\r\n     * @param {Function|null} validation Validation function. default(Deleted if it only have breakLine and blanks)\r\n     * @param {Element|null} stopParent Stop when the parent node reaches stopParent\r\n     * @returns {Object|null} {sc: previousSibling, ec: nextSibling}\r\n     */\r\n    removeItemAllParents: function (item, validation, stopParent) {\r\n        if (!item) return null;\r\n        let cc = null;\r\n        if (!validation) {\r\n            validation = function (current) {\r\n                if (current === stopParent || this.isComponent(current)) return false;\r\n                const text = current.textContent.trim();\r\n                return text.length === 0 || /^(\\n|\\u200B)+$/.test(text);\r\n            }.bind(this);\r\n        }\r\n\r\n        (function recursionFunc (element) {\r\n            if (!util.isWysiwygDiv(element)) {\r\n                const parent = element.parentNode;\r\n                if (parent && validation(element)) {\r\n                    cc = {\r\n                        sc: element.previousElementSibling,\r\n                        ec: element.nextElementSibling\r\n                    };\r\n                    util.removeItem(element);\r\n                    recursionFunc(parent);\r\n                }\r\n            }\r\n        }(item));\r\n\r\n        return cc;\r\n    },\r\n\r\n    /**\r\n     * @description Detach Nested all nested lists under the \"baseNode\".\r\n     * Returns a list with nested removed.\r\n     * @param {Node} baseNode Element on which to base.\r\n     * @param {Boolean} all If true, it also detach all nested lists of a returned list.\r\n     * @returns {Element}\r\n     */\r\n    detachNestedList: function (baseNode, all) {\r\n        const rNode = this._deleteNestedList(baseNode);\r\n        let rangeElement, cNodes;\r\n\r\n        if (rNode) {\r\n            rangeElement = rNode.cloneNode(false);\r\n            cNodes = rNode.childNodes;\r\n            const index = this.getPositionIndex(baseNode);\r\n            while (cNodes[index]) {\r\n                rangeElement.appendChild(cNodes[index]);\r\n            }\r\n        } else {\r\n            rangeElement = baseNode;\r\n        }\r\n        \r\n        let rChildren;\r\n        if (!all) {\r\n            const depth = this.getElementDepth(baseNode) + 2;\r\n            rChildren = this.getListChildren(baseNode, function (current) { return this.isListCell(current) && !current.previousElementSibling && this.getElementDepth(current) === depth; }.bind(this));\r\n        } else {\r\n            rChildren = this.getListChildren(rangeElement, function (current) { return this.isListCell(current) && !current.previousElementSibling; }.bind(this));\r\n        }\r\n\r\n        for (let i = 0, len = rChildren.length; i < len; i++) {\r\n            this._deleteNestedList(rChildren[i]);\r\n        }\r\n        \r\n        if (rNode) {\r\n            rNode.parentNode.insertBefore(rangeElement, rNode.nextSibling);\r\n            if (cNodes && cNodes.length === 0) this.removeItem(rNode);\r\n        }\r\n\r\n        return rangeElement === baseNode ? rangeElement.parentNode : rangeElement;\r\n    },\r\n\r\n    /**\r\n     * @description Sub function of util.detachNestedList method.\r\n     * @private\r\n     */\r\n    _deleteNestedList: function (baseNode) {\r\n        const baseParent = baseNode.parentNode;\r\n        let sibling = baseParent;\r\n        let parent = sibling.parentNode;\r\n        let liSibling, liParent, child, index, c;\r\n        \r\n        while (this.isListCell(parent)) {\r\n            index = this.getPositionIndex(baseNode);\r\n            liSibling = parent.nextElementSibling;\r\n            liParent = parent.parentNode;\r\n            child = sibling;\r\n            while(child) {\r\n                sibling = sibling.nextSibling;\r\n                if (this.isList(child)) {\r\n                    c = child.childNodes;\r\n                    while (c[index]) {\r\n                        liParent.insertBefore(c[index], liSibling);\r\n                    }\r\n                    if (c.length === 0) this.removeItem(child);\r\n                } else {\r\n                    liParent.appendChild(child);\r\n                }\r\n                child = sibling;\r\n            }\r\n            sibling = liParent;\r\n            parent = liParent.parentNode;\r\n        }\r\n\r\n        if (baseParent.children.length === 0) this.removeItem(baseParent);\r\n\r\n        return liParent;\r\n    },\r\n\r\n    /**\r\n     * @description Split all tags based on \"baseNode\"\r\n     * Returns the last element of the splited tag.\r\n     * @param {Node} baseNode Element or text node on which to base\r\n     * @param {Number|Node|null} offset Text offset of \"baseNode\" (Only valid when \"baseNode\" is a text node)\r\n     * @param {Number} depth The nesting depth of the element being split. (default: 0)\r\n     * @returns {Element}\r\n     */\r\n    splitElement: function (baseNode, offset, depth) {\r\n        if (this.isWysiwygDiv(baseNode)) return baseNode;\r\n\r\n        if (!!offset && !this.isNumber(offset)) {\r\n            const children =  baseNode.childNodes;\r\n            let index = this.getPositionIndex(offset);\r\n            const prev = baseNode.cloneNode(false);\r\n            const next = baseNode.cloneNode(false);\r\n            for (let i = 0, len = children.length; i < len; i++) {\r\n                if (i < index) prev.appendChild(children[i]);\r\n                else if (i > index) next.appendChild(children[i]);\r\n                else continue;\r\n                i--;\r\n                len--;\r\n                index--;\r\n            }\r\n\r\n            if (prev.childNodes.length > 0) baseNode.parentNode.insertBefore(prev, baseNode);\r\n            if (next.childNodes.length > 0) baseNode.parentNode.insertBefore(next, baseNode.nextElementSibling);\r\n\r\n            return baseNode;\r\n        }\r\n\r\n        const bp = baseNode.parentNode;\r\n        let index = 0, newEl, children, temp;\r\n        let next = true;\r\n        if (!depth || depth < 0) depth = 0;\r\n\r\n        if (baseNode.nodeType === 3) {\r\n            index = this.getPositionIndex(baseNode);\r\n            if (offset >= 0) {\r\n                baseNode.splitText(offset);\r\n                const after = this.getNodeFromPath([index + 1], bp);\r\n                if (this.onlyZeroWidthSpace(after)) after.data = this.zeroWidthSpace;\r\n            }\r\n        } else if (baseNode.nodeType === 1) {\r\n            if (!baseNode.previousSibling) {\r\n                if (this.getElementDepth(baseNode) === depth) next = false;\r\n            } else {\r\n                baseNode = baseNode.previousSibling;\r\n            }\r\n        }\r\n\r\n        let depthEl = baseNode;\r\n        while (this.getElementDepth(depthEl) > depth) {\r\n            index = this.getPositionIndex(depthEl) + 1;\r\n            depthEl = depthEl.parentNode;\r\n\r\n            temp = newEl;\r\n            newEl = depthEl.cloneNode(false);\r\n            children = depthEl.childNodes;\r\n\r\n            if (temp) {\r\n                if (this.isListCell(newEl) && this.isList(temp) && temp.firstElementChild) {\r\n                    newEl.innerHTML = temp.firstElementChild.innerHTML;\r\n                    util.removeItem(temp.firstElementChild);\r\n                    if (temp.children.length > 0) newEl.appendChild(temp);\r\n                } else {\r\n                    newEl.appendChild(temp);\r\n                }\r\n            }\r\n\r\n            while (children[index]) {\r\n                newEl.appendChild(children[index]);\r\n            }\r\n        }\r\n\r\n        if (depthEl.childNodes.length <= 1 && (!depthEl.firstChild || depthEl.firstChild.textContent.length === 0)) depthEl.innerHTML = '<br>';\r\n\r\n        const pElement = depthEl.parentNode;\r\n        if (next) depthEl = depthEl.nextSibling;\r\n        if (!newEl) return depthEl;\r\n\r\n        this.mergeSameTags(newEl, null, false);\r\n        this.mergeNestedTags(newEl, function (current) { return this.isList(current); }.bind(this));\r\n        \r\n        if (newEl.childNodes.length > 0) pElement.insertBefore(newEl, depthEl);\r\n        else newEl = depthEl;\r\n\r\n        if (bp.childNodes.length === 0) this.removeItem(bp);\r\n\r\n        return newEl;\r\n    },\r\n\r\n    /**\r\n     * @description Use with \"npdePath (util.getNodePath)\" to merge the same attributes and tags if they are present and modify the nodepath.\r\n     * If \"offset\" has been changed, it will return as much \"offset\" as it has been modified.\r\n     * An array containing change offsets is returned in the order of the \"nodePathArray\" array.\r\n     * @param {Element} element Element\r\n     * @param {Array|null} nodePathArray Array of NodePath object ([util.getNodePath(), ..])\r\n     * @param {Boolean} onlyText If true, non-text nodes(!util._isIgnoreNodeChange) like 'span', 'strong'.. are ignored.\r\n     * @returns {Array} [offset, ..]\r\n     */\r\n    mergeSameTags: function (element, nodePathArray, onlyText) {\r\n        const inst = this;\r\n        const nodePathLen = nodePathArray ? nodePathArray.length : 0;\r\n        let offsets = null;\r\n        \r\n        if (nodePathLen) {\r\n            offsets = this._w.Array.apply(null, new this._w.Array(nodePathLen)).map(this._w.Number.prototype.valueOf, 0);\r\n        }\r\n\r\n        (function recursionFunc(current, depth, depthIndex) {\r\n            const children = current.childNodes;\r\n            \r\n            for (let i = 0, len = children.length, child, next; i < len; i++) {\r\n                child = children[i];\r\n                next = children[i + 1];\r\n                if (!child) break;\r\n                if((onlyText && inst._isIgnoreNodeChange(child)) || (!onlyText && (inst.isTable(child) || inst.isListCell(child) || (inst.isFormatElement(child) && !inst.isFreeFormatElement(child))))) {\r\n                    if (inst.isTable(child) || inst.isListCell(child)) {\r\n                        recursionFunc(child, depth + 1, i);\r\n                    }\r\n                    continue;\r\n                }\r\n                if (len === 1 && current.nodeName === child.nodeName && current.parentNode) {\r\n                    // update nodePath\r\n                    if (nodePathLen) {\r\n                        let path, c, p, cDepth, spliceDepth;\r\n                        for (let n = 0; n < nodePathLen; n++) {\r\n                            path = nodePathArray[n];\r\n                            if (path && path[depth] === i) {\r\n                                c = child, p = current, cDepth = depth, spliceDepth = true;\r\n                                while (cDepth >= 0) {\r\n                                    if (inst.getArrayIndex(p.childNodes, c) !== path[cDepth]) {\r\n                                        spliceDepth = false;\r\n                                        break;\r\n                                    }\r\n                                    c = child.parentNode;\r\n                                    p = c.parentNode;\r\n                                    cDepth--;\r\n                                }\r\n                                if (spliceDepth) {\r\n                                    path.splice(depth, 1);\r\n                                    path[depth] = i;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // merge tag\r\n                    inst.copyTagAttributes(child, current);\r\n                    current.parentNode.insertBefore(child, current);\r\n                    inst.removeItem(current);\r\n                }\r\n                if (!next) {\r\n                    if (child.nodeType === 1) recursionFunc(child, depth + 1, i);\r\n                    break;\r\n                }\r\n\r\n                if (child.nodeName === next.nodeName && inst.isSameAttributes(child, next) && child.href === next.href) {\r\n                    const childs = child.childNodes;\r\n                    let childLength = 0;\r\n                    for (let n = 0, nLen = childs.length; n < nLen; n++) {\r\n                        if (childs[n].textContent.length > 0) childLength++;\r\n                    }\r\n\r\n                    const l = child.lastChild;\r\n                    const r = next.firstChild;\r\n                    let addOffset = 0;\r\n                    if (l && r) {\r\n                        const textOffset = l.nodeType === 3 && r.nodeType === 3;\r\n                        addOffset = l.textContent.length;\r\n                        let tempL = l.previousSibling;\r\n                        while(tempL && tempL.nodeType === 3) {\r\n                            addOffset += tempL.textContent.length;\r\n                            tempL = tempL.previousSibling;\r\n                        }\r\n\r\n                        if (childLength > 0 && l.nodeType === 3 && r.nodeType === 3 && (l.textContent.length > 0 || r.textContent.length > 0)) childLength--;\r\n\r\n                        if (nodePathLen) {\r\n                            let path = null;\r\n                            for (let n = 0; n < nodePathLen; n++) {\r\n                                path = nodePathArray[n];\r\n                                if (path && path[depth] > i) {\r\n                                    if (depth > 0 && path[depth - 1] !== depthIndex) continue;\r\n    \r\n                                    path[depth] -= 1;\r\n                                    if (path[depth + 1] >= 0 && path[depth] === i) {\r\n                                        path[depth + 1] += childLength;\r\n                                        if (textOffset) {\r\n                                            if (l && l.nodeType === 3 && r && r.nodeType === 3) {\r\n                                                offsets[n] += addOffset;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (child.nodeType === 3) {\r\n                        addOffset = child.textContent.length;\r\n                        child.textContent += next.textContent;\r\n                        if (nodePathLen) {\r\n                            let path = null;\r\n                            for (let n = 0; n < nodePathLen; n++) {\r\n                                path = nodePathArray[n];\r\n                                if (path && path[depth] > i) {\r\n                                    if (depth > 0 && path[depth - 1] !== depthIndex) continue;\r\n    \r\n                                    path[depth] -= 1;\r\n                                    if (path[depth + 1] >= 0 && path[depth] === i) {\r\n                                        path[depth + 1] += childLength;\r\n                                        offsets[n] += addOffset;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        child.innerHTML += next.innerHTML;\r\n                    }\r\n                    \r\n                    inst.removeItem(next);\r\n                    i--;\r\n                } else if (child.nodeType === 1) {\r\n                    recursionFunc(child, depth + 1, i);\r\n                }\r\n            }\r\n        })(element, 0, 0);\r\n\r\n        return offsets;\r\n    },\r\n\r\n    /**\r\n     * @description Remove nested tags without other child nodes.\r\n     * @param {Element} element Element object\r\n     * @param {Function|String|null} validation Validation function / String(\"tag1|tag2..\") / If null, all tags are applicable.\r\n     */\r\n    mergeNestedTags: function (element, validation) {\r\n        if (typeof validation === 'string') {\r\n            validation = function (current) { return this.test(current.tagName); }.bind(new this._w.RegExp('^(' + (validation ? validation : '.+') + ')$', 'i'));\r\n        } else if (typeof validation !== 'function') {\r\n            validation = function () { return true; };\r\n        }\r\n        \r\n        (function recursionFunc(current) {\r\n            let children = current.children;\r\n            if (children.length === 1 && children[0].nodeName === current.nodeName && validation(current)) {\r\n                const temp = children[0];\r\n                children = temp.children;\r\n                while (children[0]) {\r\n                    current.appendChild(children[0]);\r\n                }\r\n                current.removeChild(temp);\r\n            }\r\n\r\n            for (let i = 0, len = current.children.length; i < len; i++) {\r\n                recursionFunc(current.children[i]);\r\n            }\r\n        })(element);\r\n    },\r\n\r\n    /**\r\n     * @description Delete a empty child node of argument element\r\n     * @param {Element} element Element node\r\n     * @param {Node|null} notRemoveNode Do not remove node\r\n     */\r\n    removeEmptyNode: function (element, notRemoveNode) {\r\n        const inst = this;\r\n\r\n        if (notRemoveNode) {\r\n            notRemoveNode = inst.getParentElement(notRemoveNode, function (current) {\r\n                return element === current.parentElement;\r\n            });\r\n        }\r\n        \r\n        (function recursionFunc(current) {\r\n            if (inst._notTextNode(current) || current === notRemoveNode || inst.isNonEditable(current)) return 0;\r\n            if (current !== element && inst.onlyZeroWidthSpace(current.textContent) && (!current.firstChild || !inst.isBreak(current.firstChild)) && !current.querySelector(inst._allowedEmptyNodeList)) {\r\n                if (current.parentNode) {\r\n                    current.parentNode.removeChild(current);\r\n                    return -1;\r\n                }\r\n            } else {\r\n                const children = current.children;\r\n                for (let i = 0, len = children.length, r = 0; i < len; i++) {\r\n                    if (!children[i + r] || inst.isComponent(children[i + r])) continue;\r\n                    r += recursionFunc(children[i + r]);\r\n                }\r\n            }\r\n\r\n            return 0;\r\n        })(element);\r\n\r\n        if (element.childNodes.length === 0) element.innerHTML = '<br>';\r\n    },\r\n\r\n    /**\r\n     * @description Remove whitespace between tags in HTML string.\r\n     * @param {String} html HTML string\r\n     * @returns {String}\r\n     */\r\n    htmlRemoveWhiteSpace: function (html) {\r\n        if (!html) return '';\r\n        return html.trim().replace(/<\\/?(?!strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code|summary)[^>^<]+>\\s+(?=<)/ig, function (m) { return m.replace(/\\n/g, '').replace(/\\s+/, ' '); });\r\n    },\r\n\r\n    /**\r\n     * @description Sort a element array by depth of element.\r\n     * @param {Array} array Array object\r\n     * @param {Boolean} des true: descending order / false: ascending order\r\n     */\r\n    sortByDepth: function (array, des) {\r\n        const t = !des ? -1 : 1;\r\n        const f = t * -1;\r\n\r\n        array.sort(function (a, b) {\r\n            if (!this.isListCell(a) || !this.isListCell(b)) return 0;\r\n            a = this.getElementDepth(a);\r\n            b = this.getElementDepth(b);\r\n            return a > b ? t : a < b ? f : 0;\r\n        }.bind(this));\r\n    },\r\n\r\n    /**\r\n     * @description Nodes that need to be added without modification when changing text nodes\r\n     * @param {Node} element Element to check\r\n     * @returns {Boolean}\r\n     * @private\r\n     */\r\n    _isIgnoreNodeChange: function (element) {\r\n        return element && element.nodeType !== 3 && (this.isNonEditable(element) || !this.isTextStyleElement(element));\r\n    },\r\n\r\n    /**\r\n     * @description Nodes that must remain undetached when changing text nodes (A, Label, Code, Span:font-size)\r\n     * @param {Node|String} element Element to check\r\n     * @returns {Boolean}\r\n     * @private\r\n     */\r\n    _isMaintainedNode: function (element) {\r\n        return element && element.nodeType !== 3 && /^(a|label|code|summary)$/i.test(typeof element === 'string' ? element : element.nodeName);\r\n    },\r\n\r\n    /**\r\n     * @description Node with font-size style\r\n     * @param {Node} element Element to check\r\n     * @returns {Boolean}\r\n     * @private\r\n     */\r\n    _isSizeNode: function (element) {\r\n        return element && element.nodeType !== 3 && this.isTextStyleElement(element) && !!element.style.fontSize;\r\n    },\r\n\r\n    /**\r\n     * @description Nodes without text\r\n     * @param {Node} element Element to check\r\n     * @returns {Boolean}\r\n     * @private\r\n     */\r\n    _notTextNode: function (element) {\r\n        return element && element.nodeType !== 3 && (this.isComponent(element) || /^(br|input|select|canvas|img|iframe|audio|video)$/i.test(typeof element === 'string' ? element : element.nodeName));\r\n    },\r\n\r\n    /**\r\n     * @description Check disallowed tags\r\n     * @param {Node} element Element to check\r\n     * @returns {Boolean}\r\n     * @private\r\n     */\r\n    _disallowedTags: function (element) {\r\n        return /^(meta|script|link|style|[a-z]+\\:[a-z]+)$/i.test(element.nodeName);\r\n    },\r\n\r\n    /**\r\n     * @description Create whitelist RegExp object.\r\n     * Return RegExp format: new RegExp(\"<\\\\/?\\\\b(?!\" + list + \")\\\\b[^>^<]*+>\", \"gi\")\r\n     * @param {String} list Tags list (\"br|p|div|pre...\")\r\n     * @returns {RegExp}\r\n     */\r\n    createTagsWhitelist: function (list) {\r\n        return new RegExp('<\\\\/?\\\\b(?!\\\\b' + (list || '').replace(/\\|/g, '\\\\b|\\\\b') + '\\\\b)[^>]*>', 'gi');\r\n    },\r\n\r\n    /**\r\n     * @description Create blacklist RegExp object.\r\n     * Return RegExp format: new RegExp(\"<\\\\/?\\\\b(?:\" + list + \")\\\\b[^>^<]*+>\", \"gi\")\r\n     * @param {String} list Tags list (\"br|p|div|pre...\")\r\n     * @returns {RegExp}\r\n     */\r\n    createTagsBlacklist: function (list) {\r\n        return new RegExp('<\\\\/?\\\\b(?:\\\\b' + (list || '^').replace(/\\|/g, '\\\\b|\\\\b') + '\\\\b)[^>]*>', 'gi');\r\n    },\r\n\r\n    /**\r\n     * @description Fix tags that do not fit the editor format.\r\n     * @param {Element} documentFragment Document fragment \"DOCUMENT_FRAGMENT_NODE\" (nodeType === 11)\r\n     * @param {RegExp} htmlCheckWhitelistRegExp Editor tags whitelist (core._htmlCheckWhitelistRegExp)\r\n     * @param {RegExp} htmlCheckBlacklistRegExp Editor tags blacklist (core._htmlCheckBlacklistRegExp)\r\n     * @param {Boolean} lowLevelCheck Row level check\r\n     * @private\r\n     */\r\n    _consistencyCheckOfHTML: function (documentFragment, htmlCheckWhitelistRegExp, htmlCheckBlacklistRegExp, lowLevelCheck) {\r\n        /**\r\n         * It is can use \".children(util.getListChildren)\" to exclude text nodes, but \"documentFragment.children\" is not supported in IE.\r\n         * So check the node type and exclude the text no (current.nodeType !== 1)\r\n         */\r\n        const removeTags = [], emptyTags = [], wrongList = [], withoutFormatCells = [];\r\n\r\n        // wrong position\r\n        const wrongTags = this.getListChildNodes(documentFragment, function (current) {\r\n            if (current.nodeType !== 1) {\r\n                if (this.isList(current.parentNode)) removeTags.push(current);\r\n                return false;\r\n            }\r\n\r\n            // white list\r\n            if (htmlCheckBlacklistRegExp.test(current.nodeName) || (!htmlCheckWhitelistRegExp.test(current.nodeName) && current.childNodes.length === 0 && this.isNotCheckingNode(current))) {\r\n                removeTags.push(current);\r\n                return false;\r\n            }\r\n\r\n            const nrtag = !this.getParentElement(current, this.isNotCheckingNode);\r\n            // empty tags\r\n            if ((!this.isTable(current) && !this.isListCell(current) && !this.isAnchor(current)) && (this.isFormatElement(current) || this.isRangeFormatElement(current) || this.isTextStyleElement(current)) && current.childNodes.length === 0 && nrtag) {\r\n                emptyTags.push(current);\r\n                return false;\r\n            }\r\n\r\n            // wrong list\r\n            if (this.isList(current.parentNode) && !this.isList(current) && !this.isListCell(current)) {\r\n                wrongList.push(current);\r\n                return false;\r\n            }\r\n\r\n            // table cells\r\n            if (this.isCell(current)) {\r\n                const fel = current.firstElementChild;\r\n                if (!this.isFormatElement(fel) && !this.isRangeFormatElement(fel) && !this.isComponent(fel)) {\r\n                    withoutFormatCells.push(current);\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            const result = current.parentNode !== documentFragment && nrtag &&\r\n             ((this.isListCell(current) && !this.isList(current.parentNode)) ||\r\n              (lowLevelCheck && (this.isFormatElement(current) || this.isComponent(current)) && !this.isRangeFormatElement(current.parentNode) && !this.getParentElement(current, this.isComponent)));\r\n\r\n            return result;\r\n        }.bind(this));\r\n\r\n        for (let i = 0, len = removeTags.length; i < len; i++) {\r\n            this.removeItem(removeTags[i]);\r\n        }\r\n        \r\n        const checkTags = [];\r\n        for (let i = 0, len = wrongTags.length, t, p; i < len; i++) {\r\n            t = wrongTags[i];\r\n            p = t.parentNode;\r\n            if (!p || !p.parentNode) continue;\r\n\r\n            if (this.getParentElement(t, this.isListCell)) {\r\n                const cellChildren = t.childNodes;\r\n                for (let j = cellChildren.length - 1; len >= 0; j--) {\r\n                    p.insertBefore(t, cellChildren[j]);\r\n                }\r\n                checkTags.push(t);\r\n            } else {\r\n                p.parentNode.insertBefore(t, p);\r\n                checkTags.push(p);\r\n            }\r\n        }\r\n\r\n        for (let i = 0, len = checkTags.length, t; i < len; i++) {\r\n            t = checkTags[i];\r\n            if (this.onlyZeroWidthSpace(t.textContent.trim())) {\r\n                this.removeItem(t);\r\n            }\r\n        }\r\n\r\n        for (let i = 0, len = emptyTags.length; i < len; i++) {\r\n            this.removeItem(emptyTags[i]);\r\n        }\r\n\r\n        for (let i = 0, len = wrongList.length, t, tp, children, p; i < len; i++) {\r\n            t = wrongList[i];\r\n            p = t.parentNode;\r\n            if (!p) continue;\r\n\r\n            tp = this.createElement('LI');\r\n\r\n            if (this.isFormatElement(t)) {\r\n                children = t.childNodes;\r\n                while (children[0]) {\r\n                    tp.appendChild(children[0]);\r\n                }\r\n                p.insertBefore(tp, t);\r\n                this.removeItem(t);\r\n            } else {\r\n                t = t.nextSibling;\r\n                tp.appendChild(wrongList[i]);\r\n                p.insertBefore(tp, t);\r\n            }\r\n        }\r\n\r\n        for (let i = 0, len = withoutFormatCells.length, t, f; i < len; i++) {\r\n            t = withoutFormatCells[i];\r\n            f = this.createElement('DIV');\r\n            f.innerHTML = (t.textContent.trim().length === 0 && t.children.length === 0) ? '<br>' : t.innerHTML;\r\n            t.innerHTML = f.outerHTML;\r\n        }\r\n    },\r\n\r\n    _setDefaultOptionStyle: function (options, defaultStyle) {\r\n        let optionStyle = '';\r\n        if (options.height) optionStyle += 'height:' + options.height + ';';\r\n        if (options.minHeight) optionStyle += 'min-height:' + options.minHeight + ';';\r\n        if (options.maxHeight) optionStyle += 'max-height:' + options.maxHeight + ';';\r\n        if (options.position) optionStyle += 'position:' + options.position + ';';\r\n        if (options.width) optionStyle += 'width:' + options.width + ';';\r\n        if (options.minWidth) optionStyle += 'min-width:' + options.minWidth + ';';\r\n        if (options.maxWidth) optionStyle += 'max-width:' + options.maxWidth + ';';\r\n\r\n        let top = '', frame = '', editor = '';\r\n        defaultStyle = optionStyle + defaultStyle;\r\n        const styleArr = defaultStyle.split(';');\r\n        for (let i = 0, len = styleArr.length, s; i < len; i++) {\r\n            s = styleArr[i].trim();\r\n            if (!s) continue;\r\n            if (/^(min-|max-)?width\\s*:/.test(s) || /^(z-index|position)\\s*:/.test(s)) {\r\n                top += s + ';';\r\n                continue;\r\n            }\r\n            if (/^(min-|max-)?height\\s*:/.test(s)) {\r\n                if (/^height/.test(s) && s.split(':')[1].trim() === 'auto') {\r\n                    options.height = 'auto';\r\n                }\r\n                frame += s + ';';\r\n                continue;\r\n            }\r\n            editor += s + ';';\r\n        }\r\n\r\n        return {\r\n            top: top,\r\n            frame: frame,\r\n            editor: editor\r\n        };\r\n    },\r\n\r\n    _setIframeDocument: function (frame, options) {\r\n        frame.setAttribute('scrolling', 'auto');\r\n        frame.contentDocument.head.innerHTML = '' +\r\n            '<meta charset=\"utf-8\" />' +\r\n            '<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">' +\r\n            this._setIframeCssTags(options);\r\n        frame.contentDocument.body.className = options._editableClass;\r\n        frame.contentDocument.body.setAttribute('contenteditable', true);\r\n    },\r\n\r\n    _setIframeCssTags: function (options) {\r\n        const linkNames = options.iframeCSSFileName;\r\n        const wRegExp = this._w.RegExp;\r\n        let tagString = '';\r\n\r\n        for (let f = 0, len = linkNames.length, path; f < len; f++) {\r\n            path = [];\r\n\r\n            if (/(^https?:\\/\\/)|(^data:text\\/css,)/.test(linkNames[f])) {\r\n                path.push(linkNames[f]);\r\n            } else {\r\n                const CSSFileName = new wRegExp('(^|.*[\\\\/])' + linkNames[f] + '(\\\\..+)?\\\\.css(?:\\\\?.*|;.*)?$', 'i');\r\n                for (let c = document.getElementsByTagName('link'), i = 0, len = c.length, styleTag; i < len; i++) {\r\n                    styleTag = c[i].href.match(CSSFileName);\r\n                    if (styleTag) path.push(styleTag[0]);\r\n                }\r\n            }\r\n\r\n            if (!path || path.length === 0) throw '[SUNEDITOR.constructor.iframe.fail] The suneditor CSS files installation path could not be automatically detected. Please set the option property \"iframeCSSFileName\" before creating editor instances.';\r\n\r\n            for (let i = 0, len = path.length; i < len; i++) {\r\n                tagString += '<link href=\"' + path[i] + '\" rel=\"stylesheet\">';\r\n            }\r\n        }\r\n\r\n        return tagString + (options.height === 'auto' ? '<style>\\n/** Iframe height auto */\\nbody{height: min-content; overflow: hidden;}\\n</style>' : '');\r\n    }\r\n};\r\n\r\nexport default util;"]},"metadata":{},"sourceType":"module"}