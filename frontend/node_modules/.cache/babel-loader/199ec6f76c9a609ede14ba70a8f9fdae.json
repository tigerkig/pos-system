{"ast":null,"code":"import walkTo from '../../methods/set/walk.js';\nimport { validate, parseTime, parseYear, parseMonth } from './_parsers.js';\nexport default [// =====\n// no dates\n// =====\n// '2012-06' month-only\n{\n  reg: /^([0-9]{4})[\\-\\/]([0-9]{2})$/i,\n  parse: (s, m) => {\n    let obj = {\n      year: m[1],\n      month: parseInt(m[2], 10) - 1,\n      date: 1\n    };\n\n    if (validate(obj) === false) {\n      s.epoch = null;\n      return s;\n    }\n\n    walkTo(s, obj);\n    s = parseTime(s, m[4]);\n    return s;\n  }\n}, //February 2017 (implied date)\n{\n  reg: /^([a-z]+) ([0-9]{4})$/i,\n  parse: (s, arr) => {\n    let obj = {\n      year: parseYear(arr[2], s._today),\n      month: parseMonth(arr[1]),\n      date: s._today.date || 1\n    };\n\n    if (validate(obj) === false) {\n      s.epoch = null;\n      return s;\n    }\n\n    walkTo(s, obj);\n    s = parseTime(s, arr[4]);\n    return s;\n  }\n}, {\n  // 'q2 2002'\n  reg: /^(q[0-9])( of)?( [0-9]{4})?/i,\n  parse: (s, arr) => {\n    let quarter = arr[1] || '';\n    s = s.quarter(quarter);\n    let year = arr[3] || '';\n\n    if (year) {\n      year = year.trim();\n      s = s.year(year);\n    }\n\n    return s;\n  }\n}, {\n  // 'summer 2002'\n  reg: /^(spring|summer|winter|fall|autumn)( of)?( [0-9]{4})?/i,\n  parse: (s, arr) => {\n    let season = arr[1] || '';\n    s = s.season(season);\n    let year = arr[3] || '';\n\n    if (year) {\n      year = year.trim();\n      s = s.year(year);\n    }\n\n    return s;\n  }\n}, {\n  // '200bc'\n  reg: /^[0-9,]+ ?b\\.?c\\.?$/i,\n  parse: (s, arr) => {\n    let str = arr[0] || ''; //make year-negative\n\n    str = str.replace(/^([0-9,]+) ?b\\.?c\\.?$/i, '-$1');\n    let d = new Date();\n    let obj = {\n      year: parseInt(str.trim(), 10),\n      month: d.getMonth(),\n      date: d.getDate()\n    };\n\n    if (validate(obj) === false) {\n      s.epoch = null;\n      return s;\n    }\n\n    walkTo(s, obj);\n    s = parseTime(s);\n    return s;\n  }\n}, {\n  // '200ad'\n  reg: /^[0-9,]+ ?(a\\.?d\\.?|c\\.?e\\.?)$/i,\n  parse: (s, arr) => {\n    let str = arr[0] || ''; //remove commas\n\n    str = str.replace(/,/g, '');\n    let d = new Date();\n    let obj = {\n      year: parseInt(str.trim(), 10),\n      month: d.getMonth(),\n      date: d.getDate()\n    };\n\n    if (validate(obj) === false) {\n      s.epoch = null;\n      return s;\n    }\n\n    walkTo(s, obj);\n    s = parseTime(s);\n    return s;\n  }\n}, {\n  // '1992'\n  reg: /^[0-9]{4}( ?a\\.?d\\.?)?$/i,\n  parse: (s, arr) => {\n    let today = s._today; // using today's date, but a new month is awkward.\n\n    if (today.month && !today.date) {\n      today.date = 1;\n    }\n\n    let d = new Date();\n    let obj = {\n      year: parseYear(arr[0], today),\n      month: today.month || d.getMonth(),\n      date: today.date || d.getDate()\n    };\n\n    if (validate(obj) === false) {\n      s.epoch = null;\n      return s;\n    }\n\n    walkTo(s, obj);\n    s = parseTime(s);\n    return s;\n  }\n}];","map":{"version":3,"sources":["E:/React/pos-system/main/node_modules/spacetime/src/input/formats/04-misc.js"],"names":["walkTo","validate","parseTime","parseYear","parseMonth","reg","parse","s","m","obj","year","month","parseInt","date","epoch","arr","_today","quarter","trim","season","str","replace","d","Date","getMonth","getDate","today"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,2BAAnB;AACA,SAASC,QAAT,EAAmBC,SAAnB,EAA8BC,SAA9B,EAAyCC,UAAzC,QAA2D,eAA3D;AAEA,eAAe,CACb;AACA;AACA;AAEA;AACA;AACEC,EAAAA,GAAG,EAAE,+BADP;AAEEC,EAAAA,KAAK,EAAE,CAACC,CAAD,EAAIC,CAAJ,KAAU;AACf,QAAIC,GAAG,GAAG;AACRC,MAAAA,IAAI,EAAEF,CAAC,CAAC,CAAD,CADC;AAERG,MAAAA,KAAK,EAAEC,QAAQ,CAACJ,CAAC,CAAC,CAAD,CAAF,EAAO,EAAP,CAAR,GAAqB,CAFpB;AAGRK,MAAAA,IAAI,EAAE;AAHE,KAAV;;AAKA,QAAIZ,QAAQ,CAACQ,GAAD,CAAR,KAAkB,KAAtB,EAA6B;AAC3BF,MAAAA,CAAC,CAACO,KAAF,GAAU,IAAV;AACA,aAAOP,CAAP;AACD;;AACDP,IAAAA,MAAM,CAACO,CAAD,EAAIE,GAAJ,CAAN;AACAF,IAAAA,CAAC,GAAGL,SAAS,CAACK,CAAD,EAAIC,CAAC,CAAC,CAAD,CAAL,CAAb;AACA,WAAOD,CAAP;AACD;AAfH,CANa,EAwBb;AACA;AACEF,EAAAA,GAAG,EAAE,wBADP;AAEEC,EAAAA,KAAK,EAAE,CAACC,CAAD,EAAIQ,GAAJ,KAAY;AACjB,QAAIN,GAAG,GAAG;AACRC,MAAAA,IAAI,EAAEP,SAAS,CAACY,GAAG,CAAC,CAAD,CAAJ,EAASR,CAAC,CAACS,MAAX,CADP;AAERL,MAAAA,KAAK,EAAEP,UAAU,CAACW,GAAG,CAAC,CAAD,CAAJ,CAFT;AAGRF,MAAAA,IAAI,EAAEN,CAAC,CAACS,MAAF,CAASH,IAAT,IAAiB;AAHf,KAAV;;AAKA,QAAIZ,QAAQ,CAACQ,GAAD,CAAR,KAAkB,KAAtB,EAA6B;AAC3BF,MAAAA,CAAC,CAACO,KAAF,GAAU,IAAV;AACA,aAAOP,CAAP;AACD;;AACDP,IAAAA,MAAM,CAACO,CAAD,EAAIE,GAAJ,CAAN;AACAF,IAAAA,CAAC,GAAGL,SAAS,CAACK,CAAD,EAAIQ,GAAG,CAAC,CAAD,CAAP,CAAb;AACA,WAAOR,CAAP;AACD;AAfH,CAzBa,EA2Cb;AACE;AACAF,EAAAA,GAAG,EAAE,8BAFP;AAGEC,EAAAA,KAAK,EAAE,CAACC,CAAD,EAAIQ,GAAJ,KAAY;AACjB,QAAIE,OAAO,GAAGF,GAAG,CAAC,CAAD,CAAH,IAAU,EAAxB;AACAR,IAAAA,CAAC,GAAGA,CAAC,CAACU,OAAF,CAAUA,OAAV,CAAJ;AACA,QAAIP,IAAI,GAAGK,GAAG,CAAC,CAAD,CAAH,IAAU,EAArB;;AACA,QAAIL,IAAJ,EAAU;AACRA,MAAAA,IAAI,GAAGA,IAAI,CAACQ,IAAL,EAAP;AACAX,MAAAA,CAAC,GAAGA,CAAC,CAACG,IAAF,CAAOA,IAAP,CAAJ;AACD;;AACD,WAAOH,CAAP;AACD;AAZH,CA3Ca,EAyDb;AACE;AACAF,EAAAA,GAAG,EAAE,wDAFP;AAGEC,EAAAA,KAAK,EAAE,CAACC,CAAD,EAAIQ,GAAJ,KAAY;AACjB,QAAII,MAAM,GAAGJ,GAAG,CAAC,CAAD,CAAH,IAAU,EAAvB;AACAR,IAAAA,CAAC,GAAGA,CAAC,CAACY,MAAF,CAASA,MAAT,CAAJ;AACA,QAAIT,IAAI,GAAGK,GAAG,CAAC,CAAD,CAAH,IAAU,EAArB;;AACA,QAAIL,IAAJ,EAAU;AACRA,MAAAA,IAAI,GAAGA,IAAI,CAACQ,IAAL,EAAP;AACAX,MAAAA,CAAC,GAAGA,CAAC,CAACG,IAAF,CAAOA,IAAP,CAAJ;AACD;;AACD,WAAOH,CAAP;AACD;AAZH,CAzDa,EAuEb;AACE;AACAF,EAAAA,GAAG,EAAE,sBAFP;AAGEC,EAAAA,KAAK,EAAE,CAACC,CAAD,EAAIQ,GAAJ,KAAY;AACjB,QAAIK,GAAG,GAAGL,GAAG,CAAC,CAAD,CAAH,IAAU,EAApB,CADiB,CAEjB;;AACAK,IAAAA,GAAG,GAAGA,GAAG,CAACC,OAAJ,CAAY,wBAAZ,EAAsC,KAAtC,CAAN;AACA,QAAIC,CAAC,GAAG,IAAIC,IAAJ,EAAR;AACA,QAAId,GAAG,GAAG;AACRC,MAAAA,IAAI,EAAEE,QAAQ,CAACQ,GAAG,CAACF,IAAJ,EAAD,EAAa,EAAb,CADN;AAERP,MAAAA,KAAK,EAAEW,CAAC,CAACE,QAAF,EAFC;AAGRX,MAAAA,IAAI,EAAES,CAAC,CAACG,OAAF;AAHE,KAAV;;AAKA,QAAIxB,QAAQ,CAACQ,GAAD,CAAR,KAAkB,KAAtB,EAA6B;AAC3BF,MAAAA,CAAC,CAACO,KAAF,GAAU,IAAV;AACA,aAAOP,CAAP;AACD;;AACDP,IAAAA,MAAM,CAACO,CAAD,EAAIE,GAAJ,CAAN;AACAF,IAAAA,CAAC,GAAGL,SAAS,CAACK,CAAD,CAAb;AACA,WAAOA,CAAP;AACD;AApBH,CAvEa,EA6Fb;AACE;AACAF,EAAAA,GAAG,EAAE,iCAFP;AAGEC,EAAAA,KAAK,EAAE,CAACC,CAAD,EAAIQ,GAAJ,KAAY;AACjB,QAAIK,GAAG,GAAGL,GAAG,CAAC,CAAD,CAAH,IAAU,EAApB,CADiB,CAEjB;;AACAK,IAAAA,GAAG,GAAGA,GAAG,CAACC,OAAJ,CAAY,IAAZ,EAAkB,EAAlB,CAAN;AACA,QAAIC,CAAC,GAAG,IAAIC,IAAJ,EAAR;AACA,QAAId,GAAG,GAAG;AACRC,MAAAA,IAAI,EAAEE,QAAQ,CAACQ,GAAG,CAACF,IAAJ,EAAD,EAAa,EAAb,CADN;AAERP,MAAAA,KAAK,EAAEW,CAAC,CAACE,QAAF,EAFC;AAGRX,MAAAA,IAAI,EAAES,CAAC,CAACG,OAAF;AAHE,KAAV;;AAKA,QAAIxB,QAAQ,CAACQ,GAAD,CAAR,KAAkB,KAAtB,EAA6B;AAC3BF,MAAAA,CAAC,CAACO,KAAF,GAAU,IAAV;AACA,aAAOP,CAAP;AACD;;AACDP,IAAAA,MAAM,CAACO,CAAD,EAAIE,GAAJ,CAAN;AACAF,IAAAA,CAAC,GAAGL,SAAS,CAACK,CAAD,CAAb;AACA,WAAOA,CAAP;AACD;AApBH,CA7Fa,EAmHb;AACE;AACAF,EAAAA,GAAG,EAAE,0BAFP;AAGEC,EAAAA,KAAK,EAAE,CAACC,CAAD,EAAIQ,GAAJ,KAAY;AACjB,QAAIW,KAAK,GAAGnB,CAAC,CAACS,MAAd,CADiB,CAEjB;;AACA,QAAIU,KAAK,CAACf,KAAN,IAAe,CAACe,KAAK,CAACb,IAA1B,EAAgC;AAC9Ba,MAAAA,KAAK,CAACb,IAAN,GAAa,CAAb;AACD;;AACD,QAAIS,CAAC,GAAG,IAAIC,IAAJ,EAAR;AACA,QAAId,GAAG,GAAG;AACRC,MAAAA,IAAI,EAAEP,SAAS,CAACY,GAAG,CAAC,CAAD,CAAJ,EAASW,KAAT,CADP;AAERf,MAAAA,KAAK,EAAEe,KAAK,CAACf,KAAN,IAAeW,CAAC,CAACE,QAAF,EAFd;AAGRX,MAAAA,IAAI,EAAEa,KAAK,CAACb,IAAN,IAAcS,CAAC,CAACG,OAAF;AAHZ,KAAV;;AAKA,QAAIxB,QAAQ,CAACQ,GAAD,CAAR,KAAkB,KAAtB,EAA6B;AAC3BF,MAAAA,CAAC,CAACO,KAAF,GAAU,IAAV;AACA,aAAOP,CAAP;AACD;;AACDP,IAAAA,MAAM,CAACO,CAAD,EAAIE,GAAJ,CAAN;AACAF,IAAAA,CAAC,GAAGL,SAAS,CAACK,CAAD,CAAb;AACA,WAAOA,CAAP;AACD;AAtBH,CAnHa,CAAf","sourcesContent":["import walkTo from '../../methods/set/walk.js'\nimport { validate, parseTime, parseYear, parseMonth } from './_parsers.js'\n\nexport default [\n  // =====\n  // no dates\n  // =====\n\n  // '2012-06' month-only\n  {\n    reg: /^([0-9]{4})[\\-\\/]([0-9]{2})$/i,\n    parse: (s, m) => {\n      let obj = {\n        year: m[1],\n        month: parseInt(m[2], 10) - 1,\n        date: 1\n      }\n      if (validate(obj) === false) {\n        s.epoch = null\n        return s\n      }\n      walkTo(s, obj)\n      s = parseTime(s, m[4])\n      return s\n    }\n  },\n\n  //February 2017 (implied date)\n  {\n    reg: /^([a-z]+) ([0-9]{4})$/i,\n    parse: (s, arr) => {\n      let obj = {\n        year: parseYear(arr[2], s._today),\n        month: parseMonth(arr[1]),\n        date: s._today.date || 1\n      }\n      if (validate(obj) === false) {\n        s.epoch = null\n        return s\n      }\n      walkTo(s, obj)\n      s = parseTime(s, arr[4])\n      return s\n    }\n  },\n\n  {\n    // 'q2 2002'\n    reg: /^(q[0-9])( of)?( [0-9]{4})?/i,\n    parse: (s, arr) => {\n      let quarter = arr[1] || ''\n      s = s.quarter(quarter)\n      let year = arr[3] || ''\n      if (year) {\n        year = year.trim()\n        s = s.year(year)\n      }\n      return s\n    }\n  },\n  {\n    // 'summer 2002'\n    reg: /^(spring|summer|winter|fall|autumn)( of)?( [0-9]{4})?/i,\n    parse: (s, arr) => {\n      let season = arr[1] || ''\n      s = s.season(season)\n      let year = arr[3] || ''\n      if (year) {\n        year = year.trim()\n        s = s.year(year)\n      }\n      return s\n    }\n  },\n  {\n    // '200bc'\n    reg: /^[0-9,]+ ?b\\.?c\\.?$/i,\n    parse: (s, arr) => {\n      let str = arr[0] || ''\n      //make year-negative\n      str = str.replace(/^([0-9,]+) ?b\\.?c\\.?$/i, '-$1')\n      let d = new Date()\n      let obj = {\n        year: parseInt(str.trim(), 10),\n        month: d.getMonth(),\n        date: d.getDate()\n      }\n      if (validate(obj) === false) {\n        s.epoch = null\n        return s\n      }\n      walkTo(s, obj)\n      s = parseTime(s)\n      return s\n    }\n  },\n  {\n    // '200ad'\n    reg: /^[0-9,]+ ?(a\\.?d\\.?|c\\.?e\\.?)$/i,\n    parse: (s, arr) => {\n      let str = arr[0] || ''\n      //remove commas\n      str = str.replace(/,/g, '')\n      let d = new Date()\n      let obj = {\n        year: parseInt(str.trim(), 10),\n        month: d.getMonth(),\n        date: d.getDate()\n      }\n      if (validate(obj) === false) {\n        s.epoch = null\n        return s\n      }\n      walkTo(s, obj)\n      s = parseTime(s)\n      return s\n    }\n  },\n  {\n    // '1992'\n    reg: /^[0-9]{4}( ?a\\.?d\\.?)?$/i,\n    parse: (s, arr) => {\n      let today = s._today\n      // using today's date, but a new month is awkward.\n      if (today.month && !today.date) {\n        today.date = 1\n      }\n      let d = new Date()\n      let obj = {\n        year: parseYear(arr[0], today),\n        month: today.month || d.getMonth(),\n        date: today.date || d.getDate()\n      }\n      if (validate(obj) === false) {\n        s.epoch = null\n        return s\n      }\n      walkTo(s, obj)\n      s = parseTime(s)\n      return s\n    }\n  }\n]\n"]},"metadata":{},"sourceType":"module"}