{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { GridLinkOperator } from '../../../models';\nimport { buildWarning } from '../../../utils/warning';\nimport { gridColumnFieldsSelector, gridColumnLookupSelector } from '../columns';\n/**\n * Adds default values to the optional fields of a filter items.\n * @param {GridFilterItem} item The raw filter item.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @return {GridFilterItem} The clean filter item with an uniq ID and an always-defined operatorValue.\n * TODO: Make the typing reflect the different between GridFilterInputItem and GridFilterItem.\n */\n\nexport var cleanFilterItem = function cleanFilterItem(item, apiRef) {\n  var cleanItem = _extends({}, item);\n\n  if (cleanItem.id == null) {\n    cleanItem.id = Math.round(Math.random() * 1e5);\n  }\n\n  if (cleanItem.operatorValue == null) {\n    // Selects a default operator\n    // We don't use `apiRef.current.getColumn` because it is not ready during state initialization\n    var column = gridColumnLookupSelector(apiRef)[cleanItem.columnField];\n    cleanItem.operatorValue = column && column.filterOperators[0].value;\n  }\n\n  return cleanItem;\n};\nvar filterModelDisableMultiColumnsFilteringWarning = buildWarning(['MUI: The `filterModel` can only contain a single item when the `disableMultipleColumnsFiltering` prop is set to `true`.', 'If you are using the community version of the `DataGrid`, this prop is always `true`.'], 'error');\nvar filterModelMissingItemIdWarning = buildWarning(\"MUI: The 'id' field is required on `filterModel.items` when you use multiple filters.\", 'error');\nvar filterModelMissingItemOperatorWarning = buildWarning(['MUI: One of your filtering item have no `operatorValue` provided.', 'This property will become required on `@mui/x-data-grid@6.X`.']);\nexport var sanitizeFilterModel = function sanitizeFilterModel(model, disableMultipleColumnsFiltering, apiRef) {\n  var hasSeveralItems = model.items.length > 1;\n  var items;\n\n  if (hasSeveralItems && disableMultipleColumnsFiltering) {\n    filterModelDisableMultiColumnsFilteringWarning();\n    items = [model.items[0]];\n  } else {\n    items = model.items;\n  }\n\n  var hasItemsWithoutIds = hasSeveralItems && items.some(function (item) {\n    return item.id == null;\n  });\n  var hasItemWithoutOperator = items.some(function (item) {\n    return item.operatorValue == null;\n  });\n\n  if (hasItemsWithoutIds) {\n    filterModelMissingItemIdWarning();\n  }\n\n  if (hasItemWithoutOperator) {\n    filterModelMissingItemOperatorWarning();\n  }\n\n  if (hasItemWithoutOperator || hasItemsWithoutIds) {\n    return _extends({}, model, {\n      items: items.map(function (item) {\n        return cleanFilterItem(item, apiRef);\n      })\n    });\n  }\n\n  if (model.items !== items) {\n    return _extends({}, model, {\n      items: items\n    });\n  }\n\n  return model;\n};\nexport var mergeStateWithFilterModel = function mergeStateWithFilterModel(filterModel, disableMultipleColumnsFiltering, apiRef) {\n  return function (filteringState) {\n    return _extends({}, filteringState, {\n      filterModel: sanitizeFilterModel(filterModel, disableMultipleColumnsFiltering, apiRef)\n    });\n  };\n};\n/**\n * Generates a method to easily check if a row is matching the current filter model.\n * @param {GridFilterModel} filterModel The model with which we want to filter the rows.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\n\nexport var buildAggregatedFilterItemsApplier = function buildAggregatedFilterItemsApplier(filterModel, apiRef) {\n  var items = filterModel.items,\n      _filterModel$linkOper = filterModel.linkOperator,\n      linkOperator = _filterModel$linkOper === void 0 ? GridLinkOperator.And : _filterModel$linkOper;\n\n  var getFilterCallbackFromItem = function getFilterCallbackFromItem(filterItem) {\n    if (!filterItem.columnField || !filterItem.operatorValue) {\n      return null;\n    }\n\n    var column = apiRef.current.getColumn(filterItem.columnField);\n\n    if (!column) {\n      return null;\n    }\n\n    var parsedValue;\n\n    if (column.valueParser) {\n      var _filterItem$value;\n\n      var parser = column.valueParser;\n      parsedValue = Array.isArray(filterItem.value) ? (_filterItem$value = filterItem.value) == null ? void 0 : _filterItem$value.map(function (x) {\n        return parser(x);\n      }) : parser(filterItem.value);\n    } else {\n      parsedValue = filterItem.value;\n    }\n\n    var newFilterItem = _extends({}, filterItem, {\n      value: parsedValue\n    });\n\n    var filterOperators = column.filterOperators;\n\n    if (!(filterOperators != null && filterOperators.length)) {\n      throw new Error(\"MUI: No filter operators found for column '\".concat(column.field, \"'.\"));\n    }\n\n    var filterOperator = filterOperators.find(function (operator) {\n      return operator.value === newFilterItem.operatorValue;\n    });\n\n    if (!filterOperator) {\n      throw new Error(\"MUI: No filter operator found for column '\".concat(column.field, \"' and operator value '\").concat(newFilterItem.operatorValue, \"'.\"));\n    }\n\n    var applyFilterOnRow = filterOperator.getApplyFilterFn(newFilterItem, column);\n\n    if (typeof applyFilterOnRow !== 'function') {\n      return null;\n    }\n\n    var fn = function fn(rowId) {\n      var cellParams = apiRef.current.getCellParams(rowId, newFilterItem.columnField);\n      return applyFilterOnRow(cellParams);\n    };\n\n    return {\n      fn: fn,\n      item: newFilterItem\n    };\n  };\n\n  var appliers = items.map(getFilterCallbackFromItem).filter(function (callback) {\n    return !!callback;\n  });\n\n  if (appliers.length === 0) {\n    return null;\n  }\n\n  return function (rowId, shouldApplyFilter) {\n    var filteredAppliers = shouldApplyFilter ? appliers.filter(function (applier) {\n      return shouldApplyFilter(applier.item.columnField);\n    }) : appliers; // Return `false` as soon as we have a failing filter\n\n    if (linkOperator === GridLinkOperator.And) {\n      return filteredAppliers.every(function (applier) {\n        return applier.fn(rowId);\n      });\n    } // Return `true` as soon as we have a passing filter\n\n\n    return filteredAppliers.some(function (applier) {\n      return applier.fn(rowId);\n    });\n  };\n};\n/**\n * Generates a method to easily check if a row is matching the current quick filter.\n * @param {any[]} values The model with which we want to filter the rows.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\n\nexport var buildAggregatedQuickFilterApplier = function buildAggregatedQuickFilterApplier(filterModel, apiRef) {\n  var _filterModel$quickFil = filterModel.quickFilterValues,\n      quickFilterValues = _filterModel$quickFil === void 0 ? [] : _filterModel$quickFil,\n      _filterModel$quickFil2 = filterModel.quickFilterLogicOperator,\n      quickFilterLogicOperator = _filterModel$quickFil2 === void 0 ? GridLinkOperator.And : _filterModel$quickFil2;\n\n  if (quickFilterValues.length === 0) {\n    return null;\n  }\n\n  var columnsFields = gridColumnFieldsSelector(apiRef);\n  var appliersPerColumnField = {};\n  columnsFields.forEach(function (field) {\n    var column = apiRef.current.getColumn(field);\n    var getApplyQuickFilterFn = column == null ? void 0 : column.getApplyQuickFilterFn;\n\n    if (!getApplyQuickFilterFn) {\n      return;\n    }\n\n    appliersPerColumnField[field] = quickFilterValues.map(function (value) {\n      return getApplyQuickFilterFn(value, column, apiRef);\n    });\n  }); // If some value does not have an applier we ignore them\n\n  var sanitizedQuickFilterValues = quickFilterValues.filter(function (value, index) {\n    return Object.keys(appliersPerColumnField).some(function (field) {\n      return appliersPerColumnField[field][index] != null;\n    });\n  });\n  return function (rowId, shouldApplyFilter) {\n    var usedCellParams = {};\n    var columnsFieldsToFilter = [];\n    Object.keys(appliersPerColumnField).forEach(function (columnField) {\n      if (!shouldApplyFilter || shouldApplyFilter(columnField)) {\n        usedCellParams[columnField] = apiRef.current.getCellParams(rowId, columnField);\n        columnsFieldsToFilter.push(columnField);\n      }\n    }); // Return `false` as soon as we have a quick filter value that does not match any column\n\n    if (quickFilterLogicOperator === GridLinkOperator.And) {\n      return sanitizedQuickFilterValues.every(function (value, index) {\n        return columnsFieldsToFilter.some(function (field) {\n          var _appliersPerColumnFie, _appliersPerColumnFie2;\n\n          if (appliersPerColumnField[field][index] == null) {\n            return false;\n          }\n\n          return (_appliersPerColumnFie = (_appliersPerColumnFie2 = appliersPerColumnField[field])[index]) == null ? void 0 : _appliersPerColumnFie.call(_appliersPerColumnFie2, usedCellParams[field]);\n        });\n      });\n    } // Return `true` as soon as we have have a quick filter value that match any column\n\n\n    return sanitizedQuickFilterValues.some(function (value, index) {\n      return columnsFieldsToFilter.some(function (field) {\n        var _appliersPerColumnFie3, _appliersPerColumnFie4;\n\n        if (appliersPerColumnField[field][index] == null) {\n          return false;\n        }\n\n        return (_appliersPerColumnFie3 = (_appliersPerColumnFie4 = appliersPerColumnField[field])[index]) == null ? void 0 : _appliersPerColumnFie3.call(_appliersPerColumnFie4, usedCellParams[field]);\n      });\n    });\n  };\n};\nexport var buildAggregatedFilterApplier = function buildAggregatedFilterApplier(filterModel, apiRef) {\n  var isRowMatchingFilterItems = buildAggregatedFilterItemsApplier(filterModel, apiRef);\n  var isRowMatchingQuickFilter = buildAggregatedQuickFilterApplier(filterModel, apiRef);\n\n  if (isRowMatchingFilterItems == null && isRowMatchingQuickFilter == null) {\n    return null;\n  }\n\n  if (isRowMatchingFilterItems == null) {\n    return isRowMatchingQuickFilter;\n  }\n\n  if (isRowMatchingQuickFilter == null) {\n    return isRowMatchingFilterItems;\n  }\n\n  return function (rowId, shouldApplyFilter) {\n    return isRowMatchingFilterItems(rowId, shouldApplyFilter) && isRowMatchingQuickFilter(rowId, shouldApplyFilter);\n  };\n};","map":{"version":3,"sources":["E:/React/pos-system/main/node_modules/@mui/x-data-grid/hooks/features/filter/gridFilterUtils.js"],"names":["_extends","GridLinkOperator","buildWarning","gridColumnFieldsSelector","gridColumnLookupSelector","cleanFilterItem","item","apiRef","cleanItem","id","Math","round","random","operatorValue","column","columnField","filterOperators","value","filterModelDisableMultiColumnsFilteringWarning","filterModelMissingItemIdWarning","filterModelMissingItemOperatorWarning","sanitizeFilterModel","model","disableMultipleColumnsFiltering","hasSeveralItems","items","length","hasItemsWithoutIds","some","hasItemWithoutOperator","map","mergeStateWithFilterModel","filterModel","filteringState","buildAggregatedFilterItemsApplier","linkOperator","And","getFilterCallbackFromItem","filterItem","current","getColumn","parsedValue","valueParser","_filterItem$value","parser","Array","isArray","x","newFilterItem","Error","field","filterOperator","find","operator","applyFilterOnRow","getApplyFilterFn","fn","rowId","cellParams","getCellParams","appliers","filter","callback","shouldApplyFilter","filteredAppliers","applier","every","buildAggregatedQuickFilterApplier","quickFilterValues","quickFilterLogicOperator","columnsFields","appliersPerColumnField","forEach","getApplyQuickFilterFn","sanitizedQuickFilterValues","index","Object","keys","usedCellParams","columnsFieldsToFilter","push","_appliersPerColumnFie","_appliersPerColumnFie2","call","_appliersPerColumnFie3","_appliersPerColumnFie4","buildAggregatedFilterApplier","isRowMatchingFilterItems","isRowMatchingQuickFilter"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { GridLinkOperator } from '../../../models';\nimport { buildWarning } from '../../../utils/warning';\nimport { gridColumnFieldsSelector, gridColumnLookupSelector } from '../columns';\n\n/**\n * Adds default values to the optional fields of a filter items.\n * @param {GridFilterItem} item The raw filter item.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @return {GridFilterItem} The clean filter item with an uniq ID and an always-defined operatorValue.\n * TODO: Make the typing reflect the different between GridFilterInputItem and GridFilterItem.\n */\nexport const cleanFilterItem = (item, apiRef) => {\n  const cleanItem = _extends({}, item);\n\n  if (cleanItem.id == null) {\n    cleanItem.id = Math.round(Math.random() * 1e5);\n  }\n\n  if (cleanItem.operatorValue == null) {\n    // Selects a default operator\n    // We don't use `apiRef.current.getColumn` because it is not ready during state initialization\n    const column = gridColumnLookupSelector(apiRef)[cleanItem.columnField];\n    cleanItem.operatorValue = column && column.filterOperators[0].value;\n  }\n\n  return cleanItem;\n};\nconst filterModelDisableMultiColumnsFilteringWarning = buildWarning(['MUI: The `filterModel` can only contain a single item when the `disableMultipleColumnsFiltering` prop is set to `true`.', 'If you are using the community version of the `DataGrid`, this prop is always `true`.'], 'error');\nconst filterModelMissingItemIdWarning = buildWarning(\"MUI: The 'id' field is required on `filterModel.items` when you use multiple filters.\", 'error');\nconst filterModelMissingItemOperatorWarning = buildWarning(['MUI: One of your filtering item have no `operatorValue` provided.', 'This property will become required on `@mui/x-data-grid@6.X`.']);\nexport const sanitizeFilterModel = (model, disableMultipleColumnsFiltering, apiRef) => {\n  const hasSeveralItems = model.items.length > 1;\n  let items;\n\n  if (hasSeveralItems && disableMultipleColumnsFiltering) {\n    filterModelDisableMultiColumnsFilteringWarning();\n    items = [model.items[0]];\n  } else {\n    items = model.items;\n  }\n\n  const hasItemsWithoutIds = hasSeveralItems && items.some(item => item.id == null);\n  const hasItemWithoutOperator = items.some(item => item.operatorValue == null);\n\n  if (hasItemsWithoutIds) {\n    filterModelMissingItemIdWarning();\n  }\n\n  if (hasItemWithoutOperator) {\n    filterModelMissingItemOperatorWarning();\n  }\n\n  if (hasItemWithoutOperator || hasItemsWithoutIds) {\n    return _extends({}, model, {\n      items: items.map(item => cleanFilterItem(item, apiRef))\n    });\n  }\n\n  if (model.items !== items) {\n    return _extends({}, model, {\n      items\n    });\n  }\n\n  return model;\n};\nexport const mergeStateWithFilterModel = (filterModel, disableMultipleColumnsFiltering, apiRef) => filteringState => _extends({}, filteringState, {\n  filterModel: sanitizeFilterModel(filterModel, disableMultipleColumnsFiltering, apiRef)\n});\n/**\n * Generates a method to easily check if a row is matching the current filter model.\n * @param {GridFilterModel} filterModel The model with which we want to filter the rows.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\n\nexport const buildAggregatedFilterItemsApplier = (filterModel, apiRef) => {\n  const {\n    items,\n    linkOperator = GridLinkOperator.And\n  } = filterModel;\n\n  const getFilterCallbackFromItem = filterItem => {\n    if (!filterItem.columnField || !filterItem.operatorValue) {\n      return null;\n    }\n\n    const column = apiRef.current.getColumn(filterItem.columnField);\n\n    if (!column) {\n      return null;\n    }\n\n    let parsedValue;\n\n    if (column.valueParser) {\n      var _filterItem$value;\n\n      const parser = column.valueParser;\n      parsedValue = Array.isArray(filterItem.value) ? (_filterItem$value = filterItem.value) == null ? void 0 : _filterItem$value.map(x => parser(x)) : parser(filterItem.value);\n    } else {\n      parsedValue = filterItem.value;\n    }\n\n    const newFilterItem = _extends({}, filterItem, {\n      value: parsedValue\n    });\n\n    const filterOperators = column.filterOperators;\n\n    if (!(filterOperators != null && filterOperators.length)) {\n      throw new Error(`MUI: No filter operators found for column '${column.field}'.`);\n    }\n\n    const filterOperator = filterOperators.find(operator => operator.value === newFilterItem.operatorValue);\n\n    if (!filterOperator) {\n      throw new Error(`MUI: No filter operator found for column '${column.field}' and operator value '${newFilterItem.operatorValue}'.`);\n    }\n\n    const applyFilterOnRow = filterOperator.getApplyFilterFn(newFilterItem, column);\n\n    if (typeof applyFilterOnRow !== 'function') {\n      return null;\n    }\n\n    const fn = rowId => {\n      const cellParams = apiRef.current.getCellParams(rowId, newFilterItem.columnField);\n      return applyFilterOnRow(cellParams);\n    };\n\n    return {\n      fn,\n      item: newFilterItem\n    };\n  };\n\n  const appliers = items.map(getFilterCallbackFromItem).filter(callback => !!callback);\n\n  if (appliers.length === 0) {\n    return null;\n  }\n\n  return (rowId, shouldApplyFilter) => {\n    const filteredAppliers = shouldApplyFilter ? appliers.filter(applier => shouldApplyFilter(applier.item.columnField)) : appliers; // Return `false` as soon as we have a failing filter\n\n    if (linkOperator === GridLinkOperator.And) {\n      return filteredAppliers.every(applier => applier.fn(rowId));\n    } // Return `true` as soon as we have a passing filter\n\n\n    return filteredAppliers.some(applier => applier.fn(rowId));\n  };\n};\n/**\n * Generates a method to easily check if a row is matching the current quick filter.\n * @param {any[]} values The model with which we want to filter the rows.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\n\nexport const buildAggregatedQuickFilterApplier = (filterModel, apiRef) => {\n  const {\n    quickFilterValues = [],\n    quickFilterLogicOperator = GridLinkOperator.And\n  } = filterModel;\n\n  if (quickFilterValues.length === 0) {\n    return null;\n  }\n\n  const columnsFields = gridColumnFieldsSelector(apiRef);\n  const appliersPerColumnField = {};\n  columnsFields.forEach(field => {\n    const column = apiRef.current.getColumn(field);\n    const getApplyQuickFilterFn = column == null ? void 0 : column.getApplyQuickFilterFn;\n\n    if (!getApplyQuickFilterFn) {\n      return;\n    }\n\n    appliersPerColumnField[field] = quickFilterValues.map(value => getApplyQuickFilterFn(value, column, apiRef));\n  }); // If some value does not have an applier we ignore them\n\n  const sanitizedQuickFilterValues = quickFilterValues.filter((value, index) => Object.keys(appliersPerColumnField).some(field => appliersPerColumnField[field][index] != null));\n  return (rowId, shouldApplyFilter) => {\n    const usedCellParams = {};\n    const columnsFieldsToFilter = [];\n    Object.keys(appliersPerColumnField).forEach(columnField => {\n      if (!shouldApplyFilter || shouldApplyFilter(columnField)) {\n        usedCellParams[columnField] = apiRef.current.getCellParams(rowId, columnField);\n        columnsFieldsToFilter.push(columnField);\n      }\n    }); // Return `false` as soon as we have a quick filter value that does not match any column\n\n    if (quickFilterLogicOperator === GridLinkOperator.And) {\n      return sanitizedQuickFilterValues.every((value, index) => columnsFieldsToFilter.some(field => {\n        var _appliersPerColumnFie, _appliersPerColumnFie2;\n\n        if (appliersPerColumnField[field][index] == null) {\n          return false;\n        }\n\n        return (_appliersPerColumnFie = (_appliersPerColumnFie2 = appliersPerColumnField[field])[index]) == null ? void 0 : _appliersPerColumnFie.call(_appliersPerColumnFie2, usedCellParams[field]);\n      }));\n    } // Return `true` as soon as we have have a quick filter value that match any column\n\n\n    return sanitizedQuickFilterValues.some((value, index) => columnsFieldsToFilter.some(field => {\n      var _appliersPerColumnFie3, _appliersPerColumnFie4;\n\n      if (appliersPerColumnField[field][index] == null) {\n        return false;\n      }\n\n      return (_appliersPerColumnFie3 = (_appliersPerColumnFie4 = appliersPerColumnField[field])[index]) == null ? void 0 : _appliersPerColumnFie3.call(_appliersPerColumnFie4, usedCellParams[field]);\n    }));\n  };\n};\nexport const buildAggregatedFilterApplier = (filterModel, apiRef) => {\n  const isRowMatchingFilterItems = buildAggregatedFilterItemsApplier(filterModel, apiRef);\n  const isRowMatchingQuickFilter = buildAggregatedQuickFilterApplier(filterModel, apiRef);\n\n  if (isRowMatchingFilterItems == null && isRowMatchingQuickFilter == null) {\n    return null;\n  }\n\n  if (isRowMatchingFilterItems == null) {\n    return isRowMatchingQuickFilter;\n  }\n\n  if (isRowMatchingQuickFilter == null) {\n    return isRowMatchingFilterItems;\n  }\n\n  return (rowId, shouldApplyFilter) => isRowMatchingFilterItems(rowId, shouldApplyFilter) && isRowMatchingQuickFilter(rowId, shouldApplyFilter);\n};"]},"metadata":{},"sourceType":"module"}